["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/popmotion/dist/popmotion.cjs.js"],"~:js","shadow$provide.module$node_modules$popmotion$dist$popmotion_cjs=function(global,require,module,exports){function findSpring({duration=800,bounce=.25,velocity=0,mass=1}){let envelope;heyListen.warning(1E4>=duration,\"Spring duration must be 10 seconds or less\");let dampingRatio=1-bounce;dampingRatio=clamp(.05,1,dampingRatio);duration=clamp(.01,10,duration/1E3);1>dampingRatio?(envelope=undampedFreq=>{const exponentialDecay=undampedFreq*dampingRatio;return.001-(exponentialDecay-velocity)/(undampedFreq*\nMath.sqrt(1-dampingRatio*dampingRatio))*Math.exp(-(exponentialDecay*duration))},bounce=undampedFreq=>{var delta=undampedFreq*dampingRatio*duration;const d=delta*velocity+velocity,e=Math.pow(dampingRatio,2)*Math.pow(undampedFreq,2)*duration;delta=Math.exp(-delta);const g=Math.pow(undampedFreq,2)*Math.sqrt(1-dampingRatio*dampingRatio);return(0<-envelope(undampedFreq)+.001?-1:1)*(d-e)*delta/g}):(envelope=undampedFreq=>-.001+Math.exp(-undampedFreq*duration)*((undampedFreq-velocity)*duration+1),bounce=\nundampedFreq=>Math.exp(-undampedFreq*duration)*(velocity-undampedFreq)*duration*duration);bounce=approximateRoot(envelope,bounce,5/duration);duration*=1E3;if(isNaN(bounce))return{stiffness:100,damping:10,duration};bounce=Math.pow(bounce,2)*mass;return{stiffness:bounce,damping:2*dampingRatio*Math.sqrt(mass*bounce),duration}}function approximateRoot(envelope,derivative,initialGuess){for(let i=1;12>i;i++)initialGuess-=envelope(initialGuess)/derivative(initialGuess);return initialGuess}function isSpringType(options,\nkeys){return keys.some(key=>void 0!==options[key])}function getSpringOptions(options){let springOptions=Object.assign({velocity:0,stiffness:100,damping:10,mass:1,isResolvedFromDuration:!1},options);!isSpringType(options,physicsKeys)&&isSpringType(options,durationKeys)&&(options=findSpring(options),springOptions=Object.assign(Object.assign(Object.assign({},springOptions),options),{velocity:0,mass:1}),springOptions.isResolvedFromDuration=!0);return springOptions}function spring(_a){function createSpring(){const initialVelocity=\nvelocity?-(velocity/1E3):0,initialDelta=to-from,dampingRatio=damping/(2*Math.sqrt(stiffness*mass)),undampedAngularFreq=Math.sqrt(stiffness/mass)/1E3;void 0===restDelta&&(restDelta=Math.min(Math.abs(to-from)/100,.4));if(1>dampingRatio){const angularFreq=undampedAngularFreq*Math.sqrt(1-dampingRatio*dampingRatio);resolveSpring=t=>to-Math.exp(-dampingRatio*undampedAngularFreq*t)*((initialVelocity+dampingRatio*undampedAngularFreq*initialDelta)/angularFreq*Math.sin(angularFreq*t)+initialDelta*Math.cos(angularFreq*\nt));resolveVelocity=t=>{const envelope=Math.exp(-dampingRatio*undampedAngularFreq*t);return dampingRatio*undampedAngularFreq*envelope*(Math.sin(angularFreq*t)*(initialVelocity+dampingRatio*undampedAngularFreq*initialDelta)/angularFreq+initialDelta*Math.cos(angularFreq*t))-envelope*(Math.cos(angularFreq*t)*(initialVelocity+dampingRatio*undampedAngularFreq*initialDelta)-angularFreq*initialDelta*Math.sin(angularFreq*t))}}else if(1===dampingRatio)resolveSpring=t=>to-Math.exp(-undampedAngularFreq*t)*(initialDelta+\n(initialVelocity+undampedAngularFreq*initialDelta)*t);else{const dampedAngularFreq=undampedAngularFreq*Math.sqrt(dampingRatio*dampingRatio-1);resolveSpring=t=>{const freqForT=Math.min(dampedAngularFreq*t,300);return to-Math.exp(-dampingRatio*undampedAngularFreq*t)*((initialVelocity+dampingRatio*undampedAngularFreq*initialDelta)*Math.sinh(freqForT)+dampedAngularFreq*initialDelta*Math.cosh(freqForT))/dampedAngularFreq}}}var {from=0,to=1,restSpeed=2,restDelta}=_a;_a=tslib.__rest(_a,[\"from\",\"to\",\"restSpeed\",\n\"restDelta\"]);const state={done:!1,value:from};let {stiffness,damping,mass,velocity,duration,isResolvedFromDuration}=getSpringOptions(_a),resolveSpring=zero,resolveVelocity=zero;createSpring();return{next:t=>{const current=resolveSpring(t);if(isResolvedFromDuration)state.done=t>=duration;else{t=1E3*resolveVelocity(t);const isBelowDisplacementThreshold=Math.abs(to-current)<=restDelta;state.done=Math.abs(t)<=restSpeed&&isBelowDisplacementThreshold}state.value=state.done?to:current;return state},flipTarget:()=>\n{velocity=-velocity;[from,to]=[to,from];createSpring()}}}function hueToRgb(p,q,t){0>t&&(t+=1);1<t&&--t;return t<1/6?p+6*(q-p)*t:.5>t?q:t<2/3?p+(q-p)*(2/3-t)*6:p}function hslaToRgba({hue,saturation,lightness,alpha}){hue/=360;saturation/=100;lightness/=100;if(saturation){const q=.5>lightness?lightness*(1+saturation):lightness+saturation-lightness*saturation,p=2*lightness-q;lightness=hueToRgb(p,q,hue+1/3);saturation=hueToRgb(p,q,hue);hue=hueToRgb(p,q,hue-1/3)}else lightness=saturation=hue=lightness;\nreturn{red:Math.round(255*lightness),green:Math.round(255*saturation),blue:Math.round(255*hue),alpha}}function getMixer(origin,target){return\"number\"===typeof origin?v=>-v*origin+v*target+origin:styleValueTypes.color.test(origin)?mixColor(origin,target):mixComplex(origin,target)}function analyse(value){value=styleValueTypes.complex.parse(value);const numValues=value.length;let numNumbers=0,numRGB=0,numHSL=0;for(let i=0;i<numValues;i++)numNumbers||\"number\"===typeof value[i]?numNumbers++:void 0!==value[i].hue?\nnumHSL++:numRGB++;return{parsed:value,numNumbers,numRGB,numHSL}}function detectMixerFactory(v){if(\"number\"===typeof v)return mixNumber;if(\"string\"===typeof v)return styleValueTypes.color.test(v)?mixColor:mixComplex;if(Array.isArray(v))return mixArray;if(\"object\"===typeof v)return mixObject}function createMixers(output,ease,customMixer){const mixers=[];customMixer=customMixer||detectMixerFactory(output[0]);const numMixers=output.length-1;for(let i=0;i<numMixers;i++){let mixer=customMixer(output[i],\noutput[i+1]);ease&&(mixer=[Array.isArray(ease)?ease[i]:ease,mixer].reduce(combineFunctions));mixers.push(mixer)}return mixers}function fastInterpolate([from,to],[mixer]){return v=>mixer(progress(from,to,v))}function slowInterpolate(input,mixers){const inputLength=input.length,lastInputIndex=inputLength-1;return v=>{var mixerIndex=0;let foundMixerIndex=!1;v<=input[0]?foundMixerIndex=!0:v>=input[lastInputIndex]&&(mixerIndex=lastInputIndex-1,foundMixerIndex=!0);if(!foundMixerIndex){for(mixerIndex=1;mixerIndex<\ninputLength&&!(input[mixerIndex]>v||mixerIndex===lastInputIndex);mixerIndex++);--mixerIndex}v=progress(input[mixerIndex],input[mixerIndex+1],v);return mixers[mixerIndex](v)}}function interpolate(input,output,{clamp:isClamp=!0,ease,mixer}={}){const inputLength=input.length;heyListen.invariant(inputLength===output.length,\"Both input and output ranges must be the same length\");heyListen.invariant(!ease||!Array.isArray(ease)||ease.length===inputLength-1,\"Array of easing functions must be of length `input.length - 1`, as it applies to the transitions **between** the defined values.\");\ninput[0]>input[inputLength-1]&&(input=[].concat(input),output=[].concat(output),input.reverse(),output.reverse());output=createMixers(output,ease,mixer);const interpolator=2===inputLength?fastInterpolate(input,output):slowInterpolate(input,output);return isClamp?v=>interpolator(clamp(input[0],input[inputLength-1],v)):interpolator}function defaultEasing(values,easing){return values.map(()=>easing||easeInOut).splice(0,values.length-1)}function defaultOffset(values){const numValues=values.length;return values.map((_value,\ni)=>0!==i?i/(numValues-1):0)}function convertOffsetToTimes(offset,duration){return offset.map(o=>o*duration)}function keyframes({from=0,to=1,ease,offset,duration=300}){function createInterpolator(){return interpolate(times,values,{ease:Array.isArray(ease)?ease:defaultEasing(values,ease)})}const state={done:!1,value:from},values=Array.isArray(to)?to:[from,to],times=convertOffsetToTimes(offset&&offset.length===values.length?offset:defaultOffset(values),duration);let interpolator=createInterpolator();\nreturn{next:t=>{state.value=interpolator(t);state.done=t>=duration;return state},flipTarget:()=>{values.reverse();interpolator=createInterpolator()}}}function decay({velocity=0,from=0,power=.8,timeConstant=350,restDelta=.5,modifyTarget}){const state={done:!1,value:from};let amplitude=power*velocity;velocity=from+amplitude;const target=void 0===modifyTarget?velocity:modifyTarget(velocity);target!==velocity&&(amplitude=target-from);return{next:t=>{t=-amplitude*Math.exp(-t/timeConstant);state.done=!(t>\nrestDelta||t<-restDelta);state.value=state.done?target:target+t;return state},flipTarget:()=>{}}}function detectAnimationFromOptions(config){if(Array.isArray(config.to))return keyframes;if(types[config.type])return types[config.type];config=new Set(Object.keys(config));return config.has(\"ease\")||config.has(\"duration\")&&!config.has(\"dampingRatio\")||!(config.has(\"dampingRatio\")||config.has(\"stiffness\")||config.has(\"mass\")||config.has(\"damping\")||config.has(\"restSpeed\")||config.has(\"restDelta\"))?keyframes:\nspring}function loopElapsed(elapsed,duration,delay=0){return elapsed-duration-delay}function reverseElapsed(elapsed,duration,delay=0,isForwardPlayback=!0){return isForwardPlayback?loopElapsed(duration+-elapsed,duration,delay):duration-(elapsed-duration)+delay}function animate(_a){function update(delta){isForwardPlayback||(delta=-delta);elapsed+=delta;isComplete||(delta=animation.next(Math.max(0,elapsed)),latest=delta.value,interpolateFromNumber&&(latest=interpolateFromNumber(latest)),isComplete=isForwardPlayback?\ndelta.done:0>=elapsed);null===onUpdate||void 0===onUpdate?void 0:onUpdate(latest);if(isComplete)if(0===repeatCount&&(null!==computedDuration&&void 0!==computedDuration?computedDuration:computedDuration=elapsed),repeatCount<repeatMax){if(isForwardPlayback?elapsed>=computedDuration+repeatDelay:elapsed<=-repeatDelay)repeatCount++,\"reverse\"===repeatType?(isForwardPlayback=0===repeatCount%2,elapsed=reverseElapsed(elapsed,computedDuration,repeatDelay,isForwardPlayback)):(elapsed=loopElapsed(elapsed,computedDuration,\nrepeatDelay),\"mirror\"===repeatType&&animation.flipTarget()),isComplete=!1,onRepeat&&onRepeat()}else driverControls.stop(),onComplete&&onComplete()}var _c,{from,autoplay=!0,driver=framesync,elapsed=0,repeat:repeatMax=0,repeatType=\"loop\",repeatDelay=0,onPlay,onStop,onComplete,onRepeat,onUpdate}=_a;_a=tslib.__rest(_a,\"from autoplay driver elapsed repeat repeatType repeatDelay onPlay onStop onComplete onRepeat onUpdate\".split(\" \"));let {to}=_a,driverControls,repeatCount=0,computedDuration=_a.duration,\nlatest,isComplete=!1,isForwardPlayback=!0,interpolateFromNumber;const animator=detectAnimationFromOptions(_a);if(null===(_c=animator.needsInterpolation)||void 0===_c?0:_c.call(animator,from,to))interpolateFromNumber=interpolate([0,100],[from,to],{clamp:!1}),from=0,to=100;const animation=animator(Object.assign(Object.assign({},_a),{from,to}));autoplay&&(null===onPlay||void 0===onPlay?void 0:onPlay(),driverControls=driver(update),driverControls.start());return{stop:()=>{null===onStop||void 0===onStop?\nvoid 0:onStop();driverControls.stop()}}}function velocityPerSecond(velocity,frameDuration){return frameDuration?1E3/frameDuration*velocity:0}Object.defineProperty(exports,\"__esModule\",{value:!0});var tslib=require(\"module$node_modules$tslib$tslib\"),heyListen=require(\"module$node_modules$hey_listen$dist$index\"),styleValueTypes=require(\"module$node_modules$style_value_types$dist$valueTypes_cjs\"),sync=require(\"module$node_modules$popmotion$node_modules$framesync$dist$framesync_cjs\"),sync__default=sync&&\n\"object\"===typeof sync&&\"default\"in sync?sync:{\"default\":sync};const clamp=(min,max,v)=>Math.min(Math.max(v,min),max),durationKeys=[\"duration\",\"bounce\"],physicsKeys=[\"stiffness\",\"damping\",\"mass\"];spring.needsInterpolation=(a,b)=>\"string\"===typeof a||\"string\"===typeof b;const zero=_t=>0,progress=(from,to,value)=>{to-=from;return 0===to?1:(value-from)/to},colorTypes=[styleValueTypes.hex,styleValueTypes.rgba,styleValueTypes.hsla],getColorType=v=>colorTypes.find(type=>type.test(v)),notAnimatable=color=>\n`'${color}' is not an animatable color. Use the equivalent color code instead.`,mixColor=(from$jscomp$0,to$jscomp$0)=>{let fromColorType=getColorType(from$jscomp$0),toColorType=getColorType(to$jscomp$0);heyListen.invariant(!!fromColorType,notAnimatable(from$jscomp$0));heyListen.invariant(!!toColorType,notAnimatable(to$jscomp$0));let fromColor=fromColorType.parse(from$jscomp$0),toColor=toColorType.parse(to$jscomp$0);fromColorType===styleValueTypes.hsla&&(fromColor=hslaToRgba(fromColor),fromColorType=\nstyleValueTypes.rgba);toColorType===styleValueTypes.hsla&&(toColor=hslaToRgba(toColor),toColorType=styleValueTypes.rgba);const blended=Object.assign({},fromColor);return v=>{for(const key in blended)if(\"alpha\"!==key){var from=fromColor[key],to=toColor[key];from*=from;blended[key]=Math.sqrt(Math.max(0,v*(to*to-from)+from))}to=fromColor.alpha;blended.alpha=-v*to+v*toColor.alpha+to;return fromColorType.transform(blended)}},zeroPoint={x:0,y:0,z:0},combineFunctions=(a,b)=>v=>b(a(v)),mixArray=(from,to)=>\n{const output=[...from],numValues=output.length,blendValue=from.map((fromThis,i)=>getMixer(fromThis,to[i]));return v=>{for(let i=0;i<numValues;i++)output[i]=blendValue[i](v);return output}},mixObject=(origin,target)=>{const output=Object.assign(Object.assign({},origin),target),blendValue={};for(const key in output)void 0!==origin[key]&&void 0!==target[key]&&(blendValue[key]=getMixer(origin[key],target[key]));return v=>{for(const key in blendValue)output[key]=blendValue[key](v);return output}},mixComplex=\n(origin,target)=>{const template=styleValueTypes.complex.createTransformer(target),originStats=analyse(origin),targetStats=analyse(target);if(originStats.numHSL===targetStats.numHSL&&originStats.numRGB===targetStats.numRGB&&originStats.numNumbers>=targetStats.numNumbers)return[mixArray(originStats.parsed,targetStats.parsed),template].reduce(combineFunctions);heyListen.warning(!0,`Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);\nreturn p=>`${0<p?target:origin}`},mixNumber=(from,to)=>p=>-p*from+p*to+from;global=easing=>p=>1-easing(1-p);require=easing=>p=>.5>=p?easing(2*p)/2:(2-easing(2*(1-p)))/2;module=power=>p=>Math.pow(p,power);const createBackIn=power=>p=>p*p*((power+1)*p-power),createAnticipate=power=>{const backEasing=createBackIn(power);return p=>1>(p*=2)?.5*backEasing(p):.5*(2-Math.pow(2,-10*(p-1)))},BOUNCE_FIRST_THRESHOLD=4/11,BOUNCE_SECOND_THRESHOLD=8/11,linear=p=>p,easeIn=module(2),easeOut=global(easeIn),easeInOut=\nrequire(easeIn),circIn=p=>1-Math.sin(Math.acos(p)),circOut=global(circIn),circInOut=require(circOut),backIn=createBackIn(1.525),backOut=global(backIn),backInOut=require(backIn),anticipate=createAnticipate(1.525),ca=4356/361,cb=35442/1805,cc=16061/1805,bounceOut=p=>{if(1===p||0===p)return p;const p2=p*p;return p<BOUNCE_FIRST_THRESHOLD?7.5625*p2:p<BOUNCE_SECOND_THRESHOLD?9.075*p2-9.9*p+3.4:.9>p?ca*p2-cb*p+cc:10.8*p*p-20.52*p+10.72},bounceIn=global(bounceOut),types={keyframes,spring,decay},framesync=\nupdate=>{const passTimestamp=({delta})=>update(delta);return{start:()=>sync__default[\"default\"].update(passTimestamp,!0),stop:()=>sync.cancelSync.update(passTimestamp)}},identity=v=>v,createAttractor=(alterDisplacement=identity)=>(constant,origin,v)=>{v=origin-v;constant=-(0-constant+1)*(0-alterDisplacement(Math.abs(v)));return 0>=v?origin+constant:origin-constant},attract=createAttractor(),attractExpo=createAttractor(Math.sqrt),isPoint=point=>point.hasOwnProperty(\"x\")&&point.hasOwnProperty(\"y\"),\nisPoint3D=point=>isPoint(point)&&point.hasOwnProperty(\"z\"),toDecimal=(num,precision=2)=>{precision=Math.pow(10,precision);return Math.round(num*precision)/precision},smoothFrame=(prevValue,nextValue,duration,smoothing=0)=>toDecimal(prevValue+duration*(nextValue-prevValue)/Math.max(smoothing,duration)),calcBezier=(t,a1,a2)=>(((1-3*a2+3*a1)*t+(3*a2-6*a1))*t+3*a1)*t;exports.angle=(a,b=zeroPoint)=>180*Math.atan2(b.y-a.y,b.x-a.x)/Math.PI;exports.animate=animate;exports.anticipate=anticipate;exports.applyOffset=\n(from,to)=>{let hasReceivedFrom=!0;void 0===to&&(to=from,hasReceivedFrom=!1);return v=>{if(hasReceivedFrom)return v-from+to;from=v;hasReceivedFrom=!0;return to}};exports.attract=attract;exports.attractExpo=attractExpo;exports.backIn=backIn;exports.backInOut=backInOut;exports.backOut=backOut;exports.bounceIn=bounceIn;exports.bounceInOut=p=>.5>p?.5*(1-bounceOut(1-2*p)):.5*bounceOut(2*p-1)+.5;exports.bounceOut=bounceOut;exports.circIn=circIn;exports.circInOut=circInOut;exports.circOut=circOut;exports.clamp=\nclamp;exports.createAnticipate=createAnticipate;exports.createAttractor=createAttractor;exports.createBackIn=createBackIn;exports.createExpoIn=module;exports.cubicBezier=function(mX1,mY1,mX2,mY2){if(mX1===mY1&&mX2===mY2)return linear;const sampleValues=new Float32Array(11);for(let i=0;11>i;++i)sampleValues[i]=calcBezier(.1*i,mX1,mX2);return t=>{if(0!==t&&1!==t){for(var intervalStart=0,currentSample=1;10!==currentSample&&sampleValues[currentSample]<=t;++currentSample)intervalStart+=.1;--currentSample;\ncurrentSample=intervalStart+(t-sampleValues[currentSample])/(sampleValues[currentSample+1]-sampleValues[currentSample])*.1;var initialSlope=3*(1-3*mX2+3*mX1)*currentSample*currentSample+2*(3*mX2-6*mX1)*currentSample+3*mX1;if(.001<=initialSlope){for(intervalStart=0;8>intervalStart;++intervalStart){initialSlope=3*(1-3*mX2+3*mX1)*currentSample*currentSample+2*(3*mX2-6*mX1)*currentSample+3*mX1;if(0===initialSlope)break;var currentX=calcBezier(currentSample,mX1,mX2)-t;currentSample-=currentX/initialSlope}t=\ncurrentSample}else if(0===initialSlope)t=currentSample;else{currentSample=intervalStart;intervalStart+=.1;let i=0;do currentX=currentSample+(intervalStart-currentSample)/2,initialSlope=calcBezier(currentX,mX1,mX2)-t,0<initialSlope?intervalStart=currentX:currentSample=currentX;while(1E-7<Math.abs(initialSlope)&&10>++i);t=currentX}t=calcBezier(t,mY1,mY2)}return t}};exports.decay=decay;exports.degreesToRadians=degrees=>degrees*Math.PI/180;exports.distance=function(a,b){if(\"number\"===typeof a&&\"number\"===\ntypeof b)return Math.abs(a-b);if(isPoint(a)&&isPoint(b)){const xDelta=Math.abs(a.x-b.x),yDelta=Math.abs(a.y-b.y);a=isPoint3D(a)&&isPoint3D(b)?Math.abs(a.z-b.z):0;return Math.sqrt(Math.pow(xDelta,2)+Math.pow(yDelta,2)+Math.pow(a,2))}};exports.easeIn=easeIn;exports.easeInOut=easeInOut;exports.easeOut=easeOut;exports.inertia=function({from=0,velocity=0,min,max,power=.8,timeConstant=750,bounceStiffness=500,bounceDamping=10,restDelta=1,modifyTarget,driver,onUpdate,onComplete,onStop}){function boundaryNearest(v){return void 0===\nmin?max:void 0===max?min:Math.abs(min-v)<Math.abs(max-v)?min:max}function startAnimation(options){null===currentAnimation||void 0===currentAnimation?void 0:currentAnimation.stop();currentAnimation=animate(Object.assign(Object.assign({},options),{driver,onUpdate:v=>{var _a;null===onUpdate||void 0===onUpdate?void 0:onUpdate(v);null===(_a=options.onUpdate)||void 0===_a?void 0:_a.call(options,v)},onComplete,onStop}))}function startSpring(options){startAnimation(Object.assign({type:\"spring\",stiffness:bounceStiffness,\ndamping:bounceDamping,restDelta},options))}let currentAnimation;if(void 0!==min&&from<min||void 0!==max&&from>max)startSpring({from,velocity,to:boundaryNearest(from)});else{let target=power*velocity+from;\"undefined\"!==typeof modifyTarget&&(target=modifyTarget(target));const boundary=boundaryNearest(target),heading=boundary===min?-1:1;let prev,current;const checkBoundary=v=>{prev=current;current=v;velocity=velocityPerSecond(v-prev,sync.getFrameData().delta);(1===heading&&v>boundary||-1===heading&&\nv<boundary)&&startSpring({from:v,to:boundary,velocity})};startAnimation({type:\"decay\",from,velocity,timeConstant,power,restDelta,modifyTarget,onUpdate:void 0!==min&&target<min||void 0!==max&&target>max?checkBoundary:void 0})}return{stop:()=>null===currentAnimation||void 0===currentAnimation?void 0:currentAnimation.stop()}};exports.interpolate=interpolate;exports.isPoint=isPoint;exports.isPoint3D=isPoint3D;exports.keyframes=keyframes;exports.linear=linear;exports.mirrorEasing=require;exports.mix=(from,\nto,progress)=>-progress*from+progress*to+from;exports.mixColor=mixColor;exports.mixComplex=mixComplex;exports.pipe=(...transformers)=>transformers.reduce(combineFunctions);exports.pointFromVector=(origin,angle,distance)=>{angle=angle*Math.PI/180;return{x:distance*Math.cos(angle)+origin.x,y:distance*Math.sin(angle)+origin.y}};exports.progress=progress;exports.radiansToDegrees=radians=>180*radians/Math.PI;exports.reverseEasing=global;exports.smooth=(strength=50)=>{let previousValue=0,lastUpdated=0;\nreturn v=>{const currentFramestamp=sync.getFrameData().timestamp,timeDelta=currentFramestamp!==lastUpdated?currentFramestamp-lastUpdated:0;v=timeDelta?smoothFrame(previousValue,v,timeDelta,strength):previousValue;lastUpdated=currentFramestamp;return previousValue=v}};exports.smoothFrame=smoothFrame;exports.snap=points=>{if(\"number\"===typeof points)return v=>Math.round(v/points)*points;let i=0;const numPoints=points.length;return v=>{let lastDistance=Math.abs(points[0]-v);for(i=1;i<numPoints;i++){const point=\npoints[i],distance=Math.abs(point-v);if(0===distance)return point;if(distance>lastDistance)return points[i-1];if(i===numPoints-1)return point;lastDistance=distance}}};exports.spring=spring;exports.steps=(steps,direction=\"end\")=>progress=>{progress=\"end\"===direction?Math.min(progress,.999):Math.max(progress,.001);progress*=steps;return clamp(0,1,(\"end\"===direction?Math.floor(progress):Math.ceil(progress))/steps)};exports.toDecimal=toDecimal;exports.velocityPerFrame=function(xps,frameDuration){return xps/\n(1E3/frameDuration)};exports.velocityPerSecond=velocityPerSecond;exports.wrap=(min,max,v)=>{max-=min;return((v-min)%max+max)%max+min}}","~:source","shadow$provide[\"module$node_modules$popmotion$dist$popmotion_cjs\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar tslib = require('tslib');\nvar heyListen = require('hey-listen');\nvar styleValueTypes = require('style-value-types');\nvar sync = require('framesync');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar sync__default = /*#__PURE__*/_interopDefaultLegacy(sync);\n\nconst clamp = (min, max, v) => Math.min(Math.max(v, min), max);\n\nconst safeMin = 0.001;\nconst minDuration = 0.01;\nconst maxDuration = 10.0;\nconst minDamping = 0.05;\nconst maxDamping = 1;\nfunction findSpring({ duration = 800, bounce = 0.25, velocity = 0, mass = 1, }) {\n    let envelope;\n    let derivative;\n    heyListen.warning(duration <= maxDuration * 1000, \"Spring duration must be 10 seconds or less\");\n    let dampingRatio = 1 - bounce;\n    dampingRatio = clamp(minDamping, maxDamping, dampingRatio);\n    duration = clamp(minDuration, maxDuration, duration / 1000);\n    if (dampingRatio < 1) {\n        envelope = (undampedFreq) => {\n            const exponentialDecay = undampedFreq * dampingRatio;\n            const delta = exponentialDecay * duration;\n            const a = exponentialDecay - velocity;\n            const b = calcAngularFreq(undampedFreq, dampingRatio);\n            const c = Math.exp(-delta);\n            return safeMin - (a / b) * c;\n        };\n        derivative = (undampedFreq) => {\n            const exponentialDecay = undampedFreq * dampingRatio;\n            const delta = exponentialDecay * duration;\n            const d = delta * velocity + velocity;\n            const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq, 2) * duration;\n            const f = Math.exp(-delta);\n            const g = calcAngularFreq(Math.pow(undampedFreq, 2), dampingRatio);\n            const factor = -envelope(undampedFreq) + safeMin > 0 ? -1 : 1;\n            return (factor * ((d - e) * f)) / g;\n        };\n    }\n    else {\n        envelope = (undampedFreq) => {\n            const a = Math.exp(-undampedFreq * duration);\n            const b = (undampedFreq - velocity) * duration + 1;\n            return -safeMin + a * b;\n        };\n        derivative = (undampedFreq) => {\n            const a = Math.exp(-undampedFreq * duration);\n            const b = (velocity - undampedFreq) * (duration * duration);\n            return a * b;\n        };\n    }\n    const initialGuess = 5 / duration;\n    const undampedFreq = approximateRoot(envelope, derivative, initialGuess);\n    duration = duration * 1000;\n    if (isNaN(undampedFreq)) {\n        return {\n            stiffness: 100,\n            damping: 10,\n            duration,\n        };\n    }\n    else {\n        const stiffness = Math.pow(undampedFreq, 2) * mass;\n        return {\n            stiffness,\n            damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),\n            duration,\n        };\n    }\n}\nconst rootIterations = 12;\nfunction approximateRoot(envelope, derivative, initialGuess) {\n    let result = initialGuess;\n    for (let i = 1; i < rootIterations; i++) {\n        result = result - envelope(result) / derivative(result);\n    }\n    return result;\n}\nfunction calcAngularFreq(undampedFreq, dampingRatio) {\n    return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);\n}\n\nconst durationKeys = [\"duration\", \"bounce\"];\nconst physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\nfunction isSpringType(options, keys) {\n    return keys.some((key) => options[key] !== undefined);\n}\nfunction getSpringOptions(options) {\n    let springOptions = Object.assign({ velocity: 0.0, stiffness: 100, damping: 10, mass: 1.0, isResolvedFromDuration: false }, options);\n    if (!isSpringType(options, physicsKeys) &&\n        isSpringType(options, durationKeys)) {\n        const derived = findSpring(options);\n        springOptions = Object.assign(Object.assign(Object.assign({}, springOptions), derived), { velocity: 0.0, mass: 1.0 });\n        springOptions.isResolvedFromDuration = true;\n    }\n    return springOptions;\n}\nfunction spring(_a) {\n    var { from = 0.0, to = 1.0, restSpeed = 2, restDelta } = _a, options = tslib.__rest(_a, [\"from\", \"to\", \"restSpeed\", \"restDelta\"]);\n    const state = { done: false, value: from };\n    let { stiffness, damping, mass, velocity, duration, isResolvedFromDuration, } = getSpringOptions(options);\n    let resolveSpring = zero;\n    let resolveVelocity = zero;\n    function createSpring() {\n        const initialVelocity = velocity ? -(velocity / 1000) : 0.0;\n        const initialDelta = to - from;\n        const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n        const undampedAngularFreq = Math.sqrt(stiffness / mass) / 1000;\n        if (restDelta === undefined) {\n            restDelta = Math.min(Math.abs(to - from) / 100, 0.4);\n        }\n        if (dampingRatio < 1) {\n            const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\n            resolveSpring = (t) => {\n                const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n                return (to -\n                    envelope *\n                        (((initialVelocity +\n                            dampingRatio * undampedAngularFreq * initialDelta) /\n                            angularFreq) *\n                            Math.sin(angularFreq * t) +\n                            initialDelta * Math.cos(angularFreq * t)));\n            };\n            resolveVelocity = (t) => {\n                const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n                return (dampingRatio *\n                    undampedAngularFreq *\n                    envelope *\n                    ((Math.sin(angularFreq * t) *\n                        (initialVelocity +\n                            dampingRatio *\n                                undampedAngularFreq *\n                                initialDelta)) /\n                        angularFreq +\n                        initialDelta * Math.cos(angularFreq * t)) -\n                    envelope *\n                        (Math.cos(angularFreq * t) *\n                            (initialVelocity +\n                                dampingRatio *\n                                    undampedAngularFreq *\n                                    initialDelta) -\n                            angularFreq *\n                                initialDelta *\n                                Math.sin(angularFreq * t)));\n            };\n        }\n        else if (dampingRatio === 1) {\n            resolveSpring = (t) => to -\n                Math.exp(-undampedAngularFreq * t) *\n                    (initialDelta +\n                        (initialVelocity + undampedAngularFreq * initialDelta) *\n                            t);\n        }\n        else {\n            const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n            resolveSpring = (t) => {\n                const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n                const freqForT = Math.min(dampedAngularFreq * t, 300);\n                return (to -\n                    (envelope *\n                        ((initialVelocity +\n                            dampingRatio * undampedAngularFreq * initialDelta) *\n                            Math.sinh(freqForT) +\n                            dampedAngularFreq *\n                                initialDelta *\n                                Math.cosh(freqForT))) /\n                        dampedAngularFreq);\n            };\n        }\n    }\n    createSpring();\n    return {\n        next: (t) => {\n            const current = resolveSpring(t);\n            if (!isResolvedFromDuration) {\n                const currentVelocity = resolveVelocity(t) * 1000;\n                const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n                const isBelowDisplacementThreshold = Math.abs(to - current) <= restDelta;\n                state.done =\n                    isBelowVelocityThreshold && isBelowDisplacementThreshold;\n            }\n            else {\n                state.done = t >= duration;\n            }\n            state.value = state.done ? to : current;\n            return state;\n        },\n        flipTarget: () => {\n            velocity = -velocity;\n            [from, to] = [to, from];\n            createSpring();\n        },\n    };\n}\nspring.needsInterpolation = (a, b) => typeof a === \"string\" || typeof b === \"string\";\nconst zero = (_t) => 0;\n\nconst progress = (from, to, value) => {\n    const toFromDifference = to - from;\n    return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;\n};\n\nconst mix = (from, to, progress) => -progress * from + progress * to + from;\n\nfunction hueToRgb(p, q, t) {\n    if (t < 0)\n        t += 1;\n    if (t > 1)\n        t -= 1;\n    if (t < 1 / 6)\n        return p + (q - p) * 6 * t;\n    if (t < 1 / 2)\n        return q;\n    if (t < 2 / 3)\n        return p + (q - p) * (2 / 3 - t) * 6;\n    return p;\n}\nfunction hslaToRgba({ hue, saturation, lightness, alpha }) {\n    hue /= 360;\n    saturation /= 100;\n    lightness /= 100;\n    let red = 0;\n    let green = 0;\n    let blue = 0;\n    if (!saturation) {\n        red = green = blue = lightness;\n    }\n    else {\n        const q = lightness < 0.5\n            ? lightness * (1 + saturation)\n            : lightness + saturation - lightness * saturation;\n        const p = 2 * lightness - q;\n        red = hueToRgb(p, q, hue + 1 / 3);\n        green = hueToRgb(p, q, hue);\n        blue = hueToRgb(p, q, hue - 1 / 3);\n    }\n    return {\n        red: Math.round(red * 255),\n        green: Math.round(green * 255),\n        blue: Math.round(blue * 255),\n        alpha,\n    };\n}\n\nconst mixLinearColor = (from, to, v) => {\n    const fromExpo = from * from;\n    const toExpo = to * to;\n    return Math.sqrt(Math.max(0, v * (toExpo - fromExpo) + fromExpo));\n};\nconst colorTypes = [styleValueTypes.hex, styleValueTypes.rgba, styleValueTypes.hsla];\nconst getColorType = (v) => colorTypes.find((type) => type.test(v));\nconst notAnimatable = (color) => `'${color}' is not an animatable color. Use the equivalent color code instead.`;\nconst mixColor = (from, to) => {\n    let fromColorType = getColorType(from);\n    let toColorType = getColorType(to);\n    heyListen.invariant(!!fromColorType, notAnimatable(from));\n    heyListen.invariant(!!toColorType, notAnimatable(to));\n    let fromColor = fromColorType.parse(from);\n    let toColor = toColorType.parse(to);\n    if (fromColorType === styleValueTypes.hsla) {\n        fromColor = hslaToRgba(fromColor);\n        fromColorType = styleValueTypes.rgba;\n    }\n    if (toColorType === styleValueTypes.hsla) {\n        toColor = hslaToRgba(toColor);\n        toColorType = styleValueTypes.rgba;\n    }\n    const blended = Object.assign({}, fromColor);\n    return (v) => {\n        for (const key in blended) {\n            if (key !== \"alpha\") {\n                blended[key] = mixLinearColor(fromColor[key], toColor[key], v);\n            }\n        }\n        blended.alpha = mix(fromColor.alpha, toColor.alpha, v);\n        return fromColorType.transform(blended);\n    };\n};\n\nconst zeroPoint = {\n    x: 0,\n    y: 0,\n    z: 0\n};\nconst isNum = (v) => typeof v === 'number';\n\nconst combineFunctions = (a, b) => (v) => b(a(v));\nconst pipe = (...transformers) => transformers.reduce(combineFunctions);\n\nfunction getMixer(origin, target) {\n    if (isNum(origin)) {\n        return (v) => mix(origin, target, v);\n    }\n    else if (styleValueTypes.color.test(origin)) {\n        return mixColor(origin, target);\n    }\n    else {\n        return mixComplex(origin, target);\n    }\n}\nconst mixArray = (from, to) => {\n    const output = [...from];\n    const numValues = output.length;\n    const blendValue = from.map((fromThis, i) => getMixer(fromThis, to[i]));\n    return (v) => {\n        for (let i = 0; i < numValues; i++) {\n            output[i] = blendValue[i](v);\n        }\n        return output;\n    };\n};\nconst mixObject = (origin, target) => {\n    const output = Object.assign(Object.assign({}, origin), target);\n    const blendValue = {};\n    for (const key in output) {\n        if (origin[key] !== undefined && target[key] !== undefined) {\n            blendValue[key] = getMixer(origin[key], target[key]);\n        }\n    }\n    return (v) => {\n        for (const key in blendValue) {\n            output[key] = blendValue[key](v);\n        }\n        return output;\n    };\n};\nfunction analyse(value) {\n    const parsed = styleValueTypes.complex.parse(value);\n    const numValues = parsed.length;\n    let numNumbers = 0;\n    let numRGB = 0;\n    let numHSL = 0;\n    for (let i = 0; i < numValues; i++) {\n        if (numNumbers || typeof parsed[i] === \"number\") {\n            numNumbers++;\n        }\n        else {\n            if (parsed[i].hue !== undefined) {\n                numHSL++;\n            }\n            else {\n                numRGB++;\n            }\n        }\n    }\n    return { parsed, numNumbers, numRGB, numHSL };\n}\nconst mixComplex = (origin, target) => {\n    const template = styleValueTypes.complex.createTransformer(target);\n    const originStats = analyse(origin);\n    const targetStats = analyse(target);\n    const canInterpolate = originStats.numHSL === targetStats.numHSL &&\n        originStats.numRGB === targetStats.numRGB &&\n        originStats.numNumbers >= targetStats.numNumbers;\n    if (canInterpolate) {\n        return pipe(mixArray(originStats.parsed, targetStats.parsed), template);\n    }\n    else {\n        heyListen.warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);\n        return (p) => `${p > 0 ? target : origin}`;\n    }\n};\n\nconst mixNumber = (from, to) => (p) => mix(from, to, p);\nfunction detectMixerFactory(v) {\n    if (typeof v === 'number') {\n        return mixNumber;\n    }\n    else if (typeof v === 'string') {\n        if (styleValueTypes.color.test(v)) {\n            return mixColor;\n        }\n        else {\n            return mixComplex;\n        }\n    }\n    else if (Array.isArray(v)) {\n        return mixArray;\n    }\n    else if (typeof v === 'object') {\n        return mixObject;\n    }\n}\nfunction createMixers(output, ease, customMixer) {\n    const mixers = [];\n    const mixerFactory = customMixer || detectMixerFactory(output[0]);\n    const numMixers = output.length - 1;\n    for (let i = 0; i < numMixers; i++) {\n        let mixer = mixerFactory(output[i], output[i + 1]);\n        if (ease) {\n            const easingFunction = Array.isArray(ease) ? ease[i] : ease;\n            mixer = pipe(easingFunction, mixer);\n        }\n        mixers.push(mixer);\n    }\n    return mixers;\n}\nfunction fastInterpolate([from, to], [mixer]) {\n    return (v) => mixer(progress(from, to, v));\n}\nfunction slowInterpolate(input, mixers) {\n    const inputLength = input.length;\n    const lastInputIndex = inputLength - 1;\n    return (v) => {\n        let mixerIndex = 0;\n        let foundMixerIndex = false;\n        if (v <= input[0]) {\n            foundMixerIndex = true;\n        }\n        else if (v >= input[lastInputIndex]) {\n            mixerIndex = lastInputIndex - 1;\n            foundMixerIndex = true;\n        }\n        if (!foundMixerIndex) {\n            let i = 1;\n            for (; i < inputLength; i++) {\n                if (input[i] > v || i === lastInputIndex) {\n                    break;\n                }\n            }\n            mixerIndex = i - 1;\n        }\n        const progressInRange = progress(input[mixerIndex], input[mixerIndex + 1], v);\n        return mixers[mixerIndex](progressInRange);\n    };\n}\nfunction interpolate(input, output, { clamp: isClamp = true, ease, mixer } = {}) {\n    const inputLength = input.length;\n    heyListen.invariant(inputLength === output.length, 'Both input and output ranges must be the same length');\n    heyListen.invariant(!ease || !Array.isArray(ease) || ease.length === inputLength - 1, 'Array of easing functions must be of length `input.length - 1`, as it applies to the transitions **between** the defined values.');\n    if (input[0] > input[inputLength - 1]) {\n        input = [].concat(input);\n        output = [].concat(output);\n        input.reverse();\n        output.reverse();\n    }\n    const mixers = createMixers(output, ease, mixer);\n    const interpolator = inputLength === 2\n        ? fastInterpolate(input, mixers)\n        : slowInterpolate(input, mixers);\n    return isClamp\n        ? (v) => interpolator(clamp(input[0], input[inputLength - 1], v))\n        : interpolator;\n}\n\nconst reverseEasing = easing => p => 1 - easing(1 - p);\nconst mirrorEasing = easing => p => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;\nconst createExpoIn = (power) => p => Math.pow(p, power);\nconst createBackIn = (power) => p => p * p * ((power + 1) * p - power);\nconst createAnticipate = (power) => {\n    const backEasing = createBackIn(power);\n    return p => (p *= 2) < 1\n        ? 0.5 * backEasing(p)\n        : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));\n};\n\nconst DEFAULT_OVERSHOOT_STRENGTH = 1.525;\nconst BOUNCE_FIRST_THRESHOLD = 4.0 / 11.0;\nconst BOUNCE_SECOND_THRESHOLD = 8.0 / 11.0;\nconst BOUNCE_THIRD_THRESHOLD = 9.0 / 10.0;\nconst linear = p => p;\nconst easeIn = createExpoIn(2);\nconst easeOut = reverseEasing(easeIn);\nconst easeInOut = mirrorEasing(easeIn);\nconst circIn = p => 1 - Math.sin(Math.acos(p));\nconst circOut = reverseEasing(circIn);\nconst circInOut = mirrorEasing(circOut);\nconst backIn = createBackIn(DEFAULT_OVERSHOOT_STRENGTH);\nconst backOut = reverseEasing(backIn);\nconst backInOut = mirrorEasing(backIn);\nconst anticipate = createAnticipate(DEFAULT_OVERSHOOT_STRENGTH);\nconst ca = 4356.0 / 361.0;\nconst cb = 35442.0 / 1805.0;\nconst cc = 16061.0 / 1805.0;\nconst bounceOut = (p) => {\n    if (p === 1 || p === 0)\n        return p;\n    const p2 = p * p;\n    return p < BOUNCE_FIRST_THRESHOLD\n        ? 7.5625 * p2\n        : p < BOUNCE_SECOND_THRESHOLD\n            ? 9.075 * p2 - 9.9 * p + 3.4\n            : p < BOUNCE_THIRD_THRESHOLD\n                ? ca * p2 - cb * p + cc\n                : 10.8 * p * p - 20.52 * p + 10.72;\n};\nconst bounceIn = reverseEasing(bounceOut);\nconst bounceInOut = (p) => p < 0.5\n    ? 0.5 * (1.0 - bounceOut(1.0 - p * 2.0))\n    : 0.5 * bounceOut(p * 2.0 - 1.0) + 0.5;\n\nfunction defaultEasing(values, easing) {\n    return values.map(() => easing || easeInOut).splice(0, values.length - 1);\n}\nfunction defaultOffset(values) {\n    const numValues = values.length;\n    return values.map((_value, i) => i !== 0 ? i / (numValues - 1) : 0);\n}\nfunction convertOffsetToTimes(offset, duration) {\n    return offset.map((o) => o * duration);\n}\nfunction keyframes({ from = 0, to = 1, ease, offset, duration = 300, }) {\n    const state = { done: false, value: from };\n    const values = Array.isArray(to) ? to : [from, to];\n    const times = convertOffsetToTimes(offset && offset.length === values.length\n        ? offset\n        : defaultOffset(values), duration);\n    function createInterpolator() {\n        return interpolate(times, values, {\n            ease: Array.isArray(ease) ? ease : defaultEasing(values, ease),\n        });\n    }\n    let interpolator = createInterpolator();\n    return {\n        next: (t) => {\n            state.value = interpolator(t);\n            state.done = t >= duration;\n            return state;\n        },\n        flipTarget: () => {\n            values.reverse();\n            interpolator = createInterpolator();\n        },\n    };\n}\n\nfunction decay({ velocity = 0, from = 0, power = 0.8, timeConstant = 350, restDelta = 0.5, modifyTarget, }) {\n    const state = { done: false, value: from };\n    let amplitude = power * velocity;\n    const ideal = from + amplitude;\n    const target = modifyTarget === undefined ? ideal : modifyTarget(ideal);\n    if (target !== ideal)\n        amplitude = target - from;\n    return {\n        next: (t) => {\n            const delta = -amplitude * Math.exp(-t / timeConstant);\n            state.done = !(delta > restDelta || delta < -restDelta);\n            state.value = state.done ? target : target + delta;\n            return state;\n        },\n        flipTarget: () => { },\n    };\n}\n\nconst types = { keyframes, spring, decay };\nfunction detectAnimationFromOptions(config) {\n    if (Array.isArray(config.to)) {\n        return keyframes;\n    }\n    else if (types[config.type]) {\n        return types[config.type];\n    }\n    const keys = new Set(Object.keys(config));\n    if (keys.has(\"ease\") ||\n        (keys.has(\"duration\") && !keys.has(\"dampingRatio\"))) {\n        return keyframes;\n    }\n    else if (keys.has(\"dampingRatio\") ||\n        keys.has(\"stiffness\") ||\n        keys.has(\"mass\") ||\n        keys.has(\"damping\") ||\n        keys.has(\"restSpeed\") ||\n        keys.has(\"restDelta\")) {\n        return spring;\n    }\n    return keyframes;\n}\n\nfunction loopElapsed(elapsed, duration, delay = 0) {\n    return elapsed - duration - delay;\n}\nfunction reverseElapsed(elapsed, duration, delay = 0, isForwardPlayback = true) {\n    return isForwardPlayback\n        ? loopElapsed(duration + -elapsed, duration, delay)\n        : duration - (elapsed - duration) + delay;\n}\nfunction hasRepeatDelayElapsed(elapsed, duration, delay, isForwardPlayback) {\n    return isForwardPlayback ? elapsed >= duration + delay : elapsed <= -delay;\n}\n\nconst framesync = (update) => {\n    const passTimestamp = ({ delta }) => update(delta);\n    return {\n        start: () => sync__default[\"default\"].update(passTimestamp, true),\n        stop: () => sync.cancelSync.update(passTimestamp),\n    };\n};\nfunction animate(_a) {\n    var _b, _c;\n    var { from, autoplay = true, driver = framesync, elapsed = 0, repeat: repeatMax = 0, repeatType = \"loop\", repeatDelay = 0, onPlay, onStop, onComplete, onRepeat, onUpdate } = _a, options = tslib.__rest(_a, [\"from\", \"autoplay\", \"driver\", \"elapsed\", \"repeat\", \"repeatType\", \"repeatDelay\", \"onPlay\", \"onStop\", \"onComplete\", \"onRepeat\", \"onUpdate\"]);\n    let { to } = options;\n    let driverControls;\n    let repeatCount = 0;\n    let computedDuration = options.duration;\n    let latest;\n    let isComplete = false;\n    let isForwardPlayback = true;\n    let interpolateFromNumber;\n    const animator = detectAnimationFromOptions(options);\n    if ((_c = (_b = animator).needsInterpolation) === null || _c === void 0 ? void 0 : _c.call(_b, from, to)) {\n        interpolateFromNumber = interpolate([0, 100], [from, to], {\n            clamp: false,\n        });\n        from = 0;\n        to = 100;\n    }\n    const animation = animator(Object.assign(Object.assign({}, options), { from, to }));\n    function repeat() {\n        repeatCount++;\n        if (repeatType === \"reverse\") {\n            isForwardPlayback = repeatCount % 2 === 0;\n            elapsed = reverseElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback);\n        }\n        else {\n            elapsed = loopElapsed(elapsed, computedDuration, repeatDelay);\n            if (repeatType === \"mirror\")\n                animation.flipTarget();\n        }\n        isComplete = false;\n        onRepeat && onRepeat();\n    }\n    function complete() {\n        driverControls.stop();\n        onComplete && onComplete();\n    }\n    function update(delta) {\n        if (!isForwardPlayback)\n            delta = -delta;\n        elapsed += delta;\n        if (!isComplete) {\n            const state = animation.next(Math.max(0, elapsed));\n            latest = state.value;\n            if (interpolateFromNumber)\n                latest = interpolateFromNumber(latest);\n            isComplete = isForwardPlayback ? state.done : elapsed <= 0;\n        }\n        onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(latest);\n        if (isComplete) {\n            if (repeatCount === 0)\n                computedDuration !== null && computedDuration !== void 0 ? computedDuration : (computedDuration = elapsed);\n            if (repeatCount < repeatMax) {\n                hasRepeatDelayElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback) && repeat();\n            }\n            else {\n                complete();\n            }\n        }\n    }\n    function play() {\n        onPlay === null || onPlay === void 0 ? void 0 : onPlay();\n        driverControls = driver(update);\n        driverControls.start();\n    }\n    autoplay && play();\n    return {\n        stop: () => {\n            onStop === null || onStop === void 0 ? void 0 : onStop();\n            driverControls.stop();\n        },\n    };\n}\n\nfunction velocityPerSecond(velocity, frameDuration) {\n    return frameDuration ? velocity * (1000 / frameDuration) : 0;\n}\n\nfunction inertia({ from = 0, velocity = 0, min, max, power = 0.8, timeConstant = 750, bounceStiffness = 500, bounceDamping = 10, restDelta = 1, modifyTarget, driver, onUpdate, onComplete, onStop, }) {\n    let currentAnimation;\n    function isOutOfBounds(v) {\n        return (min !== undefined && v < min) || (max !== undefined && v > max);\n    }\n    function boundaryNearest(v) {\n        if (min === undefined)\n            return max;\n        if (max === undefined)\n            return min;\n        return Math.abs(min - v) < Math.abs(max - v) ? min : max;\n    }\n    function startAnimation(options) {\n        currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop();\n        currentAnimation = animate(Object.assign(Object.assign({}, options), { driver, onUpdate: (v) => {\n                var _a;\n                onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(v);\n                (_a = options.onUpdate) === null || _a === void 0 ? void 0 : _a.call(options, v);\n            }, onComplete,\n            onStop }));\n    }\n    function startSpring(options) {\n        startAnimation(Object.assign({ type: \"spring\", stiffness: bounceStiffness, damping: bounceDamping, restDelta }, options));\n    }\n    if (isOutOfBounds(from)) {\n        startSpring({ from, velocity, to: boundaryNearest(from) });\n    }\n    else {\n        let target = power * velocity + from;\n        if (typeof modifyTarget !== \"undefined\")\n            target = modifyTarget(target);\n        const boundary = boundaryNearest(target);\n        const heading = boundary === min ? -1 : 1;\n        let prev;\n        let current;\n        const checkBoundary = (v) => {\n            prev = current;\n            current = v;\n            velocity = velocityPerSecond(v - prev, sync.getFrameData().delta);\n            if ((heading === 1 && v > boundary) ||\n                (heading === -1 && v < boundary)) {\n                startSpring({ from: v, to: boundary, velocity });\n            }\n        };\n        startAnimation({\n            type: \"decay\",\n            from,\n            velocity,\n            timeConstant,\n            power,\n            restDelta,\n            modifyTarget,\n            onUpdate: isOutOfBounds(target) ? checkBoundary : undefined,\n        });\n    }\n    return {\n        stop: () => currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop(),\n    };\n}\n\nconst radiansToDegrees = (radians) => (radians * 180) / Math.PI;\n\nconst angle = (a, b = zeroPoint) => radiansToDegrees(Math.atan2(b.y - a.y, b.x - a.x));\n\nconst applyOffset = (from, to) => {\n    let hasReceivedFrom = true;\n    if (to === undefined) {\n        to = from;\n        hasReceivedFrom = false;\n    }\n    return (v) => {\n        if (hasReceivedFrom) {\n            return v - from + to;\n        }\n        else {\n            from = v;\n            hasReceivedFrom = true;\n            return to;\n        }\n    };\n};\n\nconst identity = (v) => v;\nconst createAttractor = (alterDisplacement = identity) => (constant, origin, v) => {\n    const displacement = origin - v;\n    const springModifiedDisplacement = -(0 - constant + 1) * (0 - alterDisplacement(Math.abs(displacement)));\n    return displacement <= 0\n        ? origin + springModifiedDisplacement\n        : origin - springModifiedDisplacement;\n};\nconst attract = createAttractor();\nconst attractExpo = createAttractor(Math.sqrt);\n\nconst degreesToRadians = (degrees) => (degrees * Math.PI) / 180;\n\nconst isPoint = (point) => point.hasOwnProperty('x') && point.hasOwnProperty('y');\n\nconst isPoint3D = (point) => isPoint(point) && point.hasOwnProperty('z');\n\nconst distance1D = (a, b) => Math.abs(a - b);\nfunction distance(a, b) {\n    if (isNum(a) && isNum(b)) {\n        return distance1D(a, b);\n    }\n    else if (isPoint(a) && isPoint(b)) {\n        const xDelta = distance1D(a.x, b.x);\n        const yDelta = distance1D(a.y, b.y);\n        const zDelta = isPoint3D(a) && isPoint3D(b) ? distance1D(a.z, b.z) : 0;\n        return Math.sqrt(Math.pow(xDelta, 2) + Math.pow(yDelta, 2) + Math.pow(zDelta, 2));\n    }\n}\n\nconst pointFromVector = (origin, angle, distance) => {\n    angle = degreesToRadians(angle);\n    return {\n        x: distance * Math.cos(angle) + origin.x,\n        y: distance * Math.sin(angle) + origin.y\n    };\n};\n\nconst toDecimal = (num, precision = 2) => {\n    precision = Math.pow(10, precision);\n    return Math.round(num * precision) / precision;\n};\n\nconst smoothFrame = (prevValue, nextValue, duration, smoothing = 0) => toDecimal(prevValue +\n    (duration * (nextValue - prevValue)) / Math.max(smoothing, duration));\n\nconst smooth = (strength = 50) => {\n    let previousValue = 0;\n    let lastUpdated = 0;\n    return (v) => {\n        const currentFramestamp = sync.getFrameData().timestamp;\n        const timeDelta = currentFramestamp !== lastUpdated ? currentFramestamp - lastUpdated : 0;\n        const newValue = timeDelta\n            ? smoothFrame(previousValue, v, timeDelta, strength)\n            : previousValue;\n        lastUpdated = currentFramestamp;\n        previousValue = newValue;\n        return newValue;\n    };\n};\n\nconst snap = (points) => {\n    if (typeof points === 'number') {\n        return (v) => Math.round(v / points) * points;\n    }\n    else {\n        let i = 0;\n        const numPoints = points.length;\n        return (v) => {\n            let lastDistance = Math.abs(points[0] - v);\n            for (i = 1; i < numPoints; i++) {\n                const point = points[i];\n                const distance = Math.abs(point - v);\n                if (distance === 0)\n                    return point;\n                if (distance > lastDistance)\n                    return points[i - 1];\n                if (i === numPoints - 1)\n                    return point;\n                lastDistance = distance;\n            }\n        };\n    }\n};\n\nfunction velocityPerFrame(xps, frameDuration) {\n    return xps / (1000 / frameDuration);\n}\n\nconst wrap = (min, max, v) => {\n    const rangeSize = max - min;\n    return ((((v - min) % rangeSize) + rangeSize) % rangeSize) + min;\n};\n\nconst a = (a1, a2) => 1.0 - 3.0 * a2 + 3.0 * a1;\nconst b = (a1, a2) => 3.0 * a2 - 6.0 * a1;\nconst c = (a1) => 3.0 * a1;\nconst calcBezier = (t, a1, a2) => ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;\nconst getSlope = (t, a1, a2) => 3.0 * a(a1, a2) * t * t + 2.0 * b(a1, a2) * t + c(a1);\nconst subdivisionPrecision = 0.0000001;\nconst subdivisionMaxIterations = 10;\nfunction binarySubdivide(aX, aA, aB, mX1, mX2) {\n    let currentX;\n    let currentT;\n    let i = 0;\n    do {\n        currentT = aA + (aB - aA) / 2.0;\n        currentX = calcBezier(currentT, mX1, mX2) - aX;\n        if (currentX > 0.0) {\n            aB = currentT;\n        }\n        else {\n            aA = currentT;\n        }\n    } while (Math.abs(currentX) > subdivisionPrecision &&\n        ++i < subdivisionMaxIterations);\n    return currentT;\n}\nconst newtonIterations = 8;\nconst newtonMinSlope = 0.001;\nfunction newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\n    for (let i = 0; i < newtonIterations; ++i) {\n        const currentSlope = getSlope(aGuessT, mX1, mX2);\n        if (currentSlope === 0.0) {\n            return aGuessT;\n        }\n        const currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n        aGuessT -= currentX / currentSlope;\n    }\n    return aGuessT;\n}\nconst kSplineTableSize = 11;\nconst kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\n    if (mX1 === mY1 && mX2 === mY2)\n        return linear;\n    const sampleValues = new Float32Array(kSplineTableSize);\n    for (let i = 0; i < kSplineTableSize; ++i) {\n        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n    }\n    function getTForX(aX) {\n        let intervalStart = 0.0;\n        let currentSample = 1;\n        const lastSample = kSplineTableSize - 1;\n        for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n            intervalStart += kSampleStepSize;\n        }\n        --currentSample;\n        const dist = (aX - sampleValues[currentSample]) /\n            (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n        const guessForT = intervalStart + dist * kSampleStepSize;\n        const initialSlope = getSlope(guessForT, mX1, mX2);\n        if (initialSlope >= newtonMinSlope) {\n            return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n        }\n        else if (initialSlope === 0.0) {\n            return guessForT;\n        }\n        else {\n            return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n        }\n    }\n    return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\n}\n\nconst steps = (steps, direction = 'end') => (progress) => {\n    progress =\n        direction === 'end' ? Math.min(progress, 0.999) : Math.max(progress, 0.001);\n    const expanded = progress * steps;\n    const rounded = direction === 'end' ? Math.floor(expanded) : Math.ceil(expanded);\n    return clamp(0, 1, rounded / steps);\n};\n\nexports.angle = angle;\nexports.animate = animate;\nexports.anticipate = anticipate;\nexports.applyOffset = applyOffset;\nexports.attract = attract;\nexports.attractExpo = attractExpo;\nexports.backIn = backIn;\nexports.backInOut = backInOut;\nexports.backOut = backOut;\nexports.bounceIn = bounceIn;\nexports.bounceInOut = bounceInOut;\nexports.bounceOut = bounceOut;\nexports.circIn = circIn;\nexports.circInOut = circInOut;\nexports.circOut = circOut;\nexports.clamp = clamp;\nexports.createAnticipate = createAnticipate;\nexports.createAttractor = createAttractor;\nexports.createBackIn = createBackIn;\nexports.createExpoIn = createExpoIn;\nexports.cubicBezier = cubicBezier;\nexports.decay = decay;\nexports.degreesToRadians = degreesToRadians;\nexports.distance = distance;\nexports.easeIn = easeIn;\nexports.easeInOut = easeInOut;\nexports.easeOut = easeOut;\nexports.inertia = inertia;\nexports.interpolate = interpolate;\nexports.isPoint = isPoint;\nexports.isPoint3D = isPoint3D;\nexports.keyframes = keyframes;\nexports.linear = linear;\nexports.mirrorEasing = mirrorEasing;\nexports.mix = mix;\nexports.mixColor = mixColor;\nexports.mixComplex = mixComplex;\nexports.pipe = pipe;\nexports.pointFromVector = pointFromVector;\nexports.progress = progress;\nexports.radiansToDegrees = radiansToDegrees;\nexports.reverseEasing = reverseEasing;\nexports.smooth = smooth;\nexports.smoothFrame = smoothFrame;\nexports.snap = snap;\nexports.spring = spring;\nexports.steps = steps;\nexports.toDecimal = toDecimal;\nexports.velocityPerFrame = velocityPerFrame;\nexports.velocityPerSecond = velocityPerSecond;\nexports.wrap = wrap;\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$tslib$tslib","~$module$node_modules$style_value_types$dist$valueTypes_cjs","~$shadow.js","~$module$node_modules$hey_listen$dist$index","~$module$node_modules$popmotion$node_modules$framesync$dist$framesync_cjs"]],"~:properties",["^5",["blue","stop","flipTarget","timeConstant","z","mixColor","backOut","easeIn","snap","progress","next","steps","interpolate","cubicBezier","stiffness","restDelta","driver","circOut","isPoint3D","onUpdate","modifyTarget","smooth","toDecimal","ease","isResolvedFromDuration","circIn","x","__esModule","velocityPerFrame","createBackIn","pointFromVector","attract","mirrorEasing","inertia","circInOut","bounceOut","createExpoIn","numNumbers","createAnticipate","wrap","radiansToDegrees","mixComplex","angle","bounceIn","createAttractor","animate","power","backInOut","value","linear","reverseEasing","start","bounceInOut","clamp","parsed","green","distance","pipe","smoothFrame","applyOffset","red","onComplete","duration","type","y","from","alpha","attractExpo","isPoint","easeInOut","decay","keyframes","numHSL","degreesToRadians","mass","easeOut","spring","mix","onStop","damping","to","numRGB","needsInterpolation","backIn","anticipate","done","velocityPerSecond","velocity"]],"~:compiled-at",1681642524790,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$popmotion$dist$popmotion_cjs.js\",\n\"lineCount\":43,\n\"mappings\":\"AAAAA,cAAA,CAAA,gDAAA,CAAqE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAqB7GC,QAASA,WAAU,CAAC,CAAEC,QAAA,CAAW,GAAb,CAAkBC,MAAA,CAAS,GAA3B,CAAiCC,QAAA,CAAW,CAA5C,CAA+CC,IAAA,CAAO,CAAtD,CAAD,CAA6D,CAC5E,IAAIC,QAEJC,UAAUC,CAAAA,OAAV,CAA8B,GAA9B,EAAkBN,QAAlB,CAAkD,4CAAlD,CACA,KAAIO,aAAe,CAAfA,CAAmBN,MACvBM,aAAA,CAAeC,KAAA,CAPAC,GAOA,CANAC,CAMA,CAA8BH,YAA9B,CACfP,SAAA,CAAWQ,KAAA,CAVKG,GAUL,CATKC,EASL,CAAgCZ,QAAhC,CAA2C,GAA3C,CACQ,EAAnB,CAAIO,YAAJ,EACIH,QAQA,CARYS,YAADT,EAAkB,CACzB,MAAMU,iBAAmBD,YAAnBC,CAAkCP,YAKxC,OAnBIQ,IAmBJ,EAHUD,gBAGV,CAH6BZ,QAG7B,GAF0BW,YAE1B;AAqDcG,IAAKC,CAAAA,IAAL,CAAU,CAAV,CAvD0BV,YAuD1B,CAvD0BA,YAuD1B,CArDd,EADUS,IAAKE,CAAAA,GAALC,CAAS,EAHLL,gBAGK,CAHcd,QAGd,CAATmB,CALe,CAQ7B,CAAAC,MAAA,CAAcP,YAADO,EAAkB,CAE3B,IAAMC,MADmBR,YACnBQ,CADkCd,YAClCc,CAA2BrB,QACjC,OAAMsB,EAAID,KAAJC,CAAYpB,QAAZoB,CAAuBpB,QAA7B,CACMqB,EAAIP,IAAKQ,CAAAA,GAAL,CAASjB,YAAT,CAAuB,CAAvB,CAAJgB,CAAgCP,IAAKQ,CAAAA,GAAL,CAASX,YAAT,CAAuB,CAAvB,CAAhCU,CAA4DvB,QAC5DyB,MAAAA,CAAIT,IAAKE,CAAAA,GAAL,CAAS,CAACG,KAAV,CACV,OAAMK,EAAoBV,IAAKQ,CAAAA,GAALX,CAASA,YAATA,CAAuB,CAAvBA,CAApBa,CA6CQV,IAAKC,CAAAA,IAAL,CAAU,CAAV,CA7CuCV,YA6CvC,CA7CuCA,YA6CvC,CA3Cd,QADmD,CAApCoB,CAAA,CAACvB,QAAA,CAASS,YAAT,CAADc,CA5BXZ,IA4BWY,CAAwC,CAAC,CAAzCA,CAA6C,CAC5D,GAAmBL,CAAnB,CAAuBC,CAAvB,EAA4BE,KAA5B,CAAkCC,CARP,CATnC,GAqBItB,QAKA,CALYS,YAADT,EAGA,CApCHW,IAiCGX,CACGY,IAAKE,CAAAA,GAALU,CAAS,CAACf,YAAVe,CAAyB5B,QAAzB4B,CADHxB,GAEIS,YAFJT,CAEmBF,QAFnBE,EAE+BJ,QAF/BI,CAE0C,CAF1CA,CAKX,CAAAgB,MAAA;AAAcP,YAADO,EACCJ,IAAKE,CAAAA,GAALU,CAAS,CAACf,YAAVe,CAAyB5B,QAAzB4B,CADDR,EAEElB,QAFFkB,CAEaP,YAFbO,EAE8BpB,QAF9BoB,CAEyCpB,QA5B1D,CAiCMa,OAAAA,CAAegB,eAAA,CAAgBzB,QAAhB,CAA0BgB,MAA1B,CADA,CACA,CADIpB,QACJ,CACVA,SAAX,EAAsB,GACtB,IAAI8B,KAAA,CAAMjB,MAAN,CAAJ,CACI,MAAO,CACHkB,UAAW,GADR,CAEHC,QAAS,EAFN,CAGHhC,QAHG,CAOD+B,OAAAA,CAAYf,IAAKQ,CAAAA,GAAL,CAASX,MAAT,CAAuB,CAAvB,CAAZkB,CAAwC5B,IAC9C,OAAO,CACH4B,UAAAA,MADG,CAEHC,QAAwB,CAAxBA,CAASzB,YAATyB,CAA4BhB,IAAKC,CAAAA,IAAL,CAAUd,IAAV,CAAiB4B,MAAjB,CAFzB,CAGH/B,QAHG,CAnDiE,CA2DhF6B,QAASA,gBAAe,CAACzB,QAAD,CAAWgB,UAAX,CAAuBa,YAAvB,CAAqC,CAEzD,IAAK,IAAIC,EAAI,CAAb,CAHmBC,EAGnB,CAAgBD,CAAhB,CAAoCA,CAAA,EAApC,CACaE,YAAT,EAAkBhC,QAAA,CAASgC,YAAT,CAAlB,CAAqChB,UAAA,CAAWgB,YAAX,CAEzC,OAAOA,aALkD,CAa7DC,QAASA,aAAY,CAACC,OAAD;AAAUC,IAAV,CAAgB,CACjC,MAAOA,KAAKC,CAAAA,IAAL,CAAWC,GAAD,EAA0BC,IAAAA,EAA1B,GAASJ,OAAA,CAAQG,GAAR,CAAnB,CAD0B,CAGrCE,QAASA,iBAAgB,CAACL,OAAD,CAAU,CAC/B,IAAIM,cAAgBC,MAAOC,CAAAA,MAAP,CAAc,CAAE5C,SAAU,CAAZ,CAAiB6B,UAAW,GAA5B,CAAiCC,QAAS,EAA1C,CAA8C7B,KAAM,CAApD,CAAyD4C,uBAAwB,CAAA,CAAjF,CAAd,CAAwGT,OAAxG,CAChB,EAACD,YAAA,CAAaC,OAAb,CAAsBU,WAAtB,CAAL,EACIX,YAAA,CAAaC,OAAb,CAAsBW,YAAtB,CADJ,GAEUC,OAEN,CAFgBnD,UAAA,CAAWuC,OAAX,CAEhB,CADAM,aACA,CADgBC,MAAOC,CAAAA,MAAP,CAAcD,MAAOC,CAAAA,MAAP,CAAcD,MAAOC,CAAAA,MAAP,CAAc,EAAd,CAAkBF,aAAlB,CAAd,CAAgDM,OAAhD,CAAd,CAAwE,CAAEhD,SAAU,CAAZ,CAAiBC,KAAM,CAAvB,CAAxE,CAChB,CAAAyC,aAAcG,CAAAA,sBAAd,CAAuC,CAAA,CAJ3C,CAMA,OAAOH,cARwB,CAUnCO,QAASA,OAAM,CAACC,EAAD,CAAK,CAMhBC,QAASA,aAAY,EAAG,CACpB,MAAMC;AAAkBpD,QAAA,CAAW,EAAEA,QAAF,CAAa,GAAb,CAAX,CAAgC,CAAxD,CACMqD,aAAeC,EAAfD,CAAoBE,IAD1B,CAEMlD,aAAeyB,OAAfzB,EAA0B,CAA1BA,CAA8BS,IAAKC,CAAAA,IAAL,CAAUc,SAAV,CAAsB5B,IAAtB,CAA9BI,CAFN,CAGMmD,oBAAsB1C,IAAKC,CAAAA,IAAL,CAAUc,SAAV,CAAsB5B,IAAtB,CAAtBuD,CAAoD,GACxChB,KAAAA,EAAlB,GAAIiB,SAAJ,GACIA,SADJ,CACgB3C,IAAK4C,CAAAA,GAAL,CAAS5C,IAAK6C,CAAAA,GAAL,CAASL,EAAT,CAAcC,IAAd,CAAT,CAA+B,GAA/B,CAAoC,EAApC,CADhB,CAGA,IAAmB,CAAnB,CAAIlD,YAAJ,CAAsB,CAClB,MAAMuD,YAA8BJ,mBAA9BI,CAjCQ9C,IAAKC,CAAAA,IAAL,CAAU,CAAV,CAiC2CV,YAjC3C,CAiC2CA,YAjC3C,CAkCdwD,cAAA,CAAiBC,CAADD,EAEJP,EAFIO,CACK/C,IAAKE,CAAAA,GAALd,CAAS,CAACG,YAAVH,CAAyBsD,mBAAzBtD,CAA+C4D,CAA/C5D,CADL2D,GAIDT,eAJCS,CAKAxD,YALAwD,CAKeL,mBALfK,CAKqCR,YALrCQ,EAMAD,WANAC,CAOA/C,IAAKiD,CAAAA,GAAL,CAASH,WAAT,CAAuBE,CAAvB,CAPAD,CAQAR,YARAQ,CAQe/C,IAAKkD,CAAAA,GAAL,CAASJ,WAAT;AAAuBE,CAAvB,CARfD,CAUhBI,gBAAA,CAAmBH,CAADG,EAAO,CACrB,MAAM/D,SAAWY,IAAKE,CAAAA,GAAL,CAAS,CAACX,YAAV,CAAyBmD,mBAAzB,CAA+CM,CAA/C,CACjB,OAAQzD,aAAR,CACImD,mBADJ,CAEItD,QAFJ,EAGMY,IAAKiD,CAAAA,GAAL,CAASH,WAAT,CAAuBE,CAAvB,CAHN,EAISV,eAJT,CAKY/C,YALZ,CAMgBmD,mBANhB,CAOgBH,YAPhB,EAQQO,WARR,CASQP,YATR,CASuBvC,IAAKkD,CAAAA,GAAL,CAASJ,WAAT,CAAuBE,CAAvB,CATvB,EAUI5D,QAVJ,EAWSY,IAAKkD,CAAAA,GAAL,CAASJ,WAAT,CAAuBE,CAAvB,CAXT,EAYaV,eAZb,CAagB/C,YAbhB,CAcoBmD,mBAdpB,CAeoBH,YAfpB,EAgBYO,WAhBZ,CAiBgBP,YAjBhB,CAkBgBvC,IAAKiD,CAAAA,GAAL,CAASH,WAAT,CAAuBE,CAAvB,CAlBhB,CAFqB,CAZP,CAAtB,IAmCK,IAAqB,CAArB,GAAIzD,YAAJ,CACDwD,aAAA,CAAiBC,CAADD,EAAOP,EAAPO,CACZ/C,IAAKE,CAAAA,GAAL,CAAS,CAACwC,mBAAV,CAAgCM,CAAhC,CADYD,EAEPR,YAFOQ;CAGHT,eAHGS,CAGeL,mBAHfK,CAGqCR,YAHrCQ,EAIAC,CAJAD,CADf,KAOA,CACD,MAAMK,kBAAoBV,mBAApBU,CAA0CpD,IAAKC,CAAAA,IAAL,CAAUV,YAAV,CAAyBA,YAAzB,CAAwC,CAAxC,CAChDwD,cAAA,CAAiBC,CAADD,EAAO,CAEnB,MAAMM,SAAWrD,IAAK4C,CAAAA,GAAL,CAASQ,iBAAT,CAA6BJ,CAA7B,CAAgC,GAAhC,CACjB,OAAQR,GAAR,CAFiBxC,IAAKE,CAAAA,GAALd,CAAS,CAACG,YAAVH,CAAyBsD,mBAAzBtD,CAA+C4D,CAA/C5D,CAEjB,GAEUkD,eAFV,CAGY/C,YAHZ,CAG2BmD,mBAH3B,CAGiDH,YAHjD,EAIYvC,IAAKsD,CAAAA,IAAL,CAAUD,QAAV,CAJZ,CAKYD,iBALZ,CAMgBb,YANhB,CAOgBvC,IAAKuD,CAAAA,IAAL,CAAUF,QAAV,CAPhB,EAQQD,iBAXW,CAFtB,CAlDe,CANR,IACZ,CAAEX,IAAA,CAAO,CAAT,CAAcD,EAAA,CAAK,CAAnB,CAAwBgB,SAAA,CAAY,CAApC,CAAuCb,SAAvC,CAAA,CAAqDP,EAAId,GAAAA,CAAUmC,KAAMC,CAAAA,MAAN,CAAatB,EAAb,CAAiB,CAAC,MAAD,CAAS,IAAT,CAAe,WAAf;AAA4B,WAA5B,CAAjB,CACvE,OAAMuB,MAAQ,CAAEC,KAAM,CAAA,CAAR,CAAeC,MAAOpB,IAAtB,CACd,KAAI,CAAE1B,SAAF,CAAaC,OAAb,CAAsB7B,IAAtB,CAA4BD,QAA5B,CAAsCF,QAAtC,CAAgD+C,sBAAhD,CAAA,CAA4EJ,gBAAA,CAAiBL,EAAjB,CAAhF,CACIyB,cAAgBe,IADpB,CAEIX,gBAAkBW,IAoEtBzB,aAAA,EACA,OAAO,CACH0B,KAAOf,CAADe,EAAO,CACT,MAAMC,QAAUjB,aAAA,CAAcC,CAAd,CAChB,IAAKjB,sBAAL,CAQI4B,KAAMC,CAAAA,IAAN,CAAaZ,CAAb,EAAkBhE,QARtB,KAA6B,CACnBiF,CAAAA,CAAuC,GAAvCA,CAAkBd,eAAA,CAAgBH,CAAhB,CAExB,OAAMkB,6BAA+BlE,IAAK6C,CAAAA,GAAL,CAASL,EAAT,CAAcwB,OAAd,CAA/BE,EAAyDvB,SAC/DgB,MAAMC,CAAAA,IAAN,CAFiC5D,IAAK6C,CAAAA,GAAL,CAASoB,CAAT,CAEjC,EAF8DT,SAE9D,EACgCU,4BALP,CAU7BP,KAAME,CAAAA,KAAN,CAAcF,KAAMC,CAAAA,IAAN,CAAapB,EAAb,CAAkBwB,OAChC,OAAOL,MAbE,CADV,CAgBHQ,WAAY,EAAAA;AAAM,CACdjF,QAAA,CAAW,CAACA,QACZ,EAACuD,IAAD,CAAOD,EAAP,CAAA,CAAa,CAACA,EAAD,CAAKC,IAAL,CACbJ,aAAA,EAHc,CAhBf,CA1ES,CA2GpB+B,QAASA,SAAQ,CAACC,CAAD,CAAIC,CAAJ,CAAOtB,CAAP,CAAU,CACf,CAAR,CAAIA,CAAJ,GACIA,CADJ,EACS,CADT,CAEQ,EAAR,CAAIA,CAAJ,EACI,EAAAA,CACJ,OAAIA,EAAJ,CAAQ,CAAR,CAAY,CAAZ,CACWqB,CADX,CACyB,CADzB,EACgBC,CADhB,CACoBD,CADpB,EAC6BrB,CAD7B,CAEQ,EAAR,CAAIA,CAAJ,CACWsB,CADX,CAEItB,CAAJ,CAAQ,CAAR,CAAY,CAAZ,CACWqB,CADX,EACgBC,CADhB,CACoBD,CADpB,GAC0B,CAD1B,CAC8B,CAD9B,CACkCrB,CADlC,EACuC,CADvC,CAEOqB,CAXgB,CAa3BE,QAASA,WAAU,CAAC,CAAEC,GAAF,CAAOC,UAAP,CAAmBC,SAAnB,CAA8BC,KAA9B,CAAD,CAAwC,CACvDH,GAAA,EAAO,GACPC,WAAA,EAAc,GACdC,UAAA,EAAa,GAIb,IAAKD,UAAL,CAGK,CACD,MAAMH,EAAgB,EAAZ,CAAAI,SAAA,CACJA,SADI,EACS,CADT,CACaD,UADb,EAEJC,SAFI,CAEQD,UAFR,CAEqBC,SAFrB,CAEiCD,UAF3C,CAGMJ,EAAI,CAAJA,CAAQK,SAARL,CAAoBC,CAC1BM,UAAA,CAAMR,QAAA,CAASC,CAAT,CAAYC,CAAZ,CAAeE,GAAf,CAAqB,CAArB,CAAyB,CAAzB,CACNK,WAAA,CAAQT,QAAA,CAASC,CAAT,CAAYC,CAAZ,CAAeE,GAAf,CACRM,IAAA,CAAOV,QAAA,CAASC,CAAT,CAAYC,CAAZ,CAAeE,GAAf,CAAqB,CAArB,CAAyB,CAAzB,CAPN,CAHL,IACII,UAAA,CAAMC,UAAN,CAAcC,GAAd,CAAqBJ,SAWzB;MAAO,CACHE,IAAK5E,IAAK+E,CAAAA,KAAL,CAAiB,GAAjB,CAAWH,SAAX,CADF,CAEHC,MAAO7E,IAAK+E,CAAAA,KAAL,CAAmB,GAAnB,CAAWF,UAAX,CAFJ,CAGHC,KAAM9E,IAAK+E,CAAAA,KAAL,CAAkB,GAAlB,CAAWD,GAAX,CAHH,CAIHH,KAJG,CAnBgD,CAwE3DK,QAASA,SAAQ,CAACC,MAAD,CAASC,MAAT,CAAiB,CAC9B,MAN8B,QAM9B,GANiB,MAMPD,OAAV,CACYE,CAAD,EAzFqB,CAyFMA,CAA3B,CAAWF,MAAX,CAA2BE,CAA3B,CAAmBD,MAAnB,CAAWD,MADtB,CAGSG,eAAgBC,CAAAA,KAAMC,CAAAA,IAAtB,CAA2BL,MAA3B,CAAJ,CACMM,QAAA,CAASN,MAAT,CAAiBC,MAAjB,CADN,CAIMM,UAAA,CAAWP,MAAX,CAAmBC,MAAnB,CARmB,CAqClCO,QAASA,QAAO,CAAC5B,KAAD,CAAQ,CACd6B,KAAAA,CAASN,eAAgBO,CAAAA,OAAQC,CAAAA,KAAxB,CAA8B/B,KAA9B,CACf,OAAMgC,UAAYH,KAAOI,CAAAA,MACzB,KAAIC,WAAa,CAAjB,CACIC,OAAS,CADb,CAEIC,OAAS,CACb,KAAK,IAAI/E,EAAI,CAAb,CAAgBA,CAAhB,CAAoB2E,SAApB,CAA+B3E,CAAA,EAA/B,CACQ6E,UAAJ,EAAuC,QAAvC,GAAkB,MAAOL,MAAA,CAAOxE,CAAP,CAAzB,CACI6E,UAAA,EADJ,CAI0BrE,IAAAA,EAAtB,GAAIgE,KAAA,CAAOxE,CAAP,CAAUsD,CAAAA,GAAd;AACIyB,MAAA,EADJ,CAIID,MAAA,EAIZ,OAAO,CAAEN,OAAAA,KAAF,CAAUK,UAAV,CAAsBC,MAAtB,CAA8BC,MAA9B,CAnBa,CAsCxBC,QAASA,mBAAkB,CAACf,CAAD,CAAI,CAC3B,GAAiB,QAAjB,GAAI,MAAOA,EAAX,CACI,MAAOgB,UAEN,IAAiB,QAAjB,GAAI,MAAOhB,EAAX,CACD,MAAIC,gBAAgBC,CAAAA,KAAMC,CAAAA,IAAtB,CAA2BH,CAA3B,CAAJ,CACWI,QADX,CAIWC,UAGV,IAAIY,KAAMC,CAAAA,OAAN,CAAclB,CAAd,CAAJ,CACD,MAAOmB,SAEN,IAAiB,QAAjB,GAAI,MAAOnB,EAAX,CACD,MAAOoB,UAhBgB,CAmB/BC,QAASA,aAAY,CAACC,MAAD,CAASC,IAAT,CAAeC,WAAf,CAA4B,CAC7C,MAAMC,OAAS,EACTC,YAAAA,CAAeF,WAAfE,EAA8BX,kBAAA,CAAmBO,MAAA,CAAO,CAAP,CAAnB,CACpC,OAAMK,UAAYL,MAAOX,CAAAA,MAAnBgB,CAA4B,CAClC,KAAK,IAAI5F,EAAI,CAAb,CAAgBA,CAAhB,CAAoB4F,SAApB,CAA+B5F,CAAA,EAA/B,CAAoC,CAChC,IAAI6F,MAAQF,WAAA,CAAaJ,MAAA,CAAOvF,CAAP,CAAb;AAAwBuF,MAAA,CAAOvF,CAAP,CAAW,CAAX,CAAxB,CACRwF,KAAJ,GAEIK,KAFJ,CAEiBC,CADUZ,KAAMC,CAAAA,OAAN,CAAcK,IAAd,CAAAM,CAAsBN,IAAA,CAAKxF,CAAL,CAAtB8F,CAAgCN,IAC1CM,CAAgBD,KAAhBC,CAxGsBC,CAAAA,MAAb,CAAoBC,gBAApB,CAsG1B,CAIAN,OAAOO,CAAAA,IAAP,CAAYJ,KAAZ,CANgC,CAQpC,MAAOH,OAZsC,CAcjDQ,QAASA,gBAAe,CAAC,CAAC3E,IAAD,CAAOD,EAAP,CAAD,CAAa,CAACuE,KAAD,CAAb,CAAsB,CAC1C,MAAQ5B,EAAD,EAAO4B,KAAA,CAAMM,QAAA,CAAS5E,IAAT,CAAeD,EAAf,CAAmB2C,CAAnB,CAAN,CAD4B,CAG9CmC,QAASA,gBAAe,CAACC,KAAD,CAAQX,MAAR,CAAgB,CACpC,MAAMY,YAAcD,KAAMzB,CAAAA,MAA1B,CACM2B,eAAiBD,WAAjBC,CAA+B,CACrC,OAAQtC,EAAD,EAAO,CACV,IAAIuC,WAAa,CACjB,KAAIC,gBAAkB,CAAA,CAClBxC,EAAJ,EAASoC,KAAA,CAAM,CAAN,CAAT,CACII,eADJ,CACsB,CAAA,CADtB,CAGSxC,CAHT,EAGcoC,KAAA,CAAME,cAAN,CAHd,GAIIC,UACA,CADaD,cACb,CAD8B,CAC9B,CAAAE,eAAA,CAAkB,CAAA,CALtB,CAOA,IAAI,CAACA,eAAL,CAAsB,CAElB,IADIzG,UACJ,CADQ,CACR,CAAOA,UAAP;AAAWsG,WAAX,EACQ,EAAAD,KAAA,CAAMrG,UAAN,CAAA,CAAWiE,CAAX,EAAgBjE,UAAhB,GAAsBuG,cAAtB,CADR,CAAwBvG,UAAA,EAAxB,EAKa,EAAAA,UAPK,CAShB0G,CAAAA,CAAkBP,QAAA,CAASE,KAAA,CAAMG,UAAN,CAAT,CAA4BH,KAAA,CAAMG,UAAN,CAAmB,CAAnB,CAA5B,CAAmDvC,CAAnD,CACxB,OAAOyB,OAAA,CAAOc,UAAP,CAAA,CAAmBE,CAAnB,CApBG,CAHsB,CA0BxCC,QAASA,YAAW,CAACN,KAAD,CAAQd,MAAR,CAAgB,CAAE,MAAOqB,OAAA,CAAU,CAAA,CAAnB,CAAyBpB,IAAzB,CAA+BK,KAA/B,CAAA,CAAyC,EAAzD,CAA6D,CAC7E,MAAMS,YAAcD,KAAMzB,CAAAA,MAC1BzG,UAAU0I,CAAAA,SAAV,CAAoBP,WAApB,GAAoCf,MAAOX,CAAAA,MAA3C,CAAmD,sDAAnD,CACAzG,UAAU0I,CAAAA,SAAV,CAAoB,CAACrB,IAArB,EAA6B,CAACN,KAAMC,CAAAA,OAAN,CAAcK,IAAd,CAA9B,EAAqDA,IAAKZ,CAAAA,MAA1D,GAAqE0B,WAArE,CAAmF,CAAnF,CAAsF,kIAAtF,CACID;KAAA,CAAM,CAAN,CAAJ,CAAeA,KAAA,CAAMC,WAAN,CAAoB,CAApB,CAAf,GACID,KAGA,CAHQ,EAAGS,CAAAA,MAAH,CAAUT,KAAV,CAGR,CAFAd,MAEA,CAFS,EAAGuB,CAAAA,MAAH,CAAUvB,MAAV,CAET,CADAc,KAAMU,CAAAA,OAAN,EACA,CAAAxB,MAAOwB,CAAAA,OAAP,EAJJ,CAMMrB,OAAAA,CAASJ,YAAA,CAAaC,MAAb,CAAqBC,IAArB,CAA2BK,KAA3B,CACf,OAAMmB,aAA+B,CAAhB,GAAAV,WAAA,CACfJ,eAAA,CAAgBG,KAAhB,CAAuBX,MAAvB,CADe,CAEfU,eAAA,CAAgBC,KAAhB,CAAuBX,MAAvB,CACN,OAAOkB,QAAA,CACA3C,CAAD,EAAO+C,YAAA,CAAa1I,KAAA,CAAM+H,KAAA,CAAM,CAAN,CAAN,CAAgBA,KAAA,CAAMC,WAAN,CAAoB,CAApB,CAAhB,CAAwCrC,CAAxC,CAAb,CADN,CAED+C,YAhBuE,CAiEjFC,QAASA,cAAa,CAACC,MAAD,CAASC,MAAT,CAAiB,CACnC,MAAOD,OAAOE,CAAAA,GAAP,CAAW,EAAA,EAAMD,MAAN,EAAgBE,SAA3B,CAAsCC,CAAAA,MAAtC,CAA6C,CAA7C,CAAgDJ,MAAOtC,CAAAA,MAAvD,CAAgE,CAAhE,CAD4B,CAGvC2C,QAASA,cAAa,CAACL,MAAD,CAAS,CAC3B,MAAMvC,UAAYuC,MAAOtC,CAAAA,MACzB,OAAOsC,OAAOE,CAAAA,GAAP,CAAW,CAACI,MAAD;AAASxH,CAAT,CAAA,EAAqB,CAAN,GAAAA,CAAA,CAAUA,CAAV,EAAe2E,SAAf,CAA2B,CAA3B,EAAgC,CAA1D,CAFoB,CAI/B8C,QAASA,qBAAoB,CAACC,MAAD,CAAS5J,QAAT,CAAmB,CAC5C,MAAO4J,OAAON,CAAAA,GAAP,CAAYO,CAAD,EAAOA,CAAP,CAAW7J,QAAtB,CADqC,CAGhD8J,QAASA,UAAS,CAAC,CAAErG,IAAA,CAAO,CAAT,CAAYD,EAAA,CAAK,CAAjB,CAAoBkE,IAApB,CAA0BkC,MAA1B,CAAkC5J,QAAA,CAAW,GAA7C,CAAD,CAAsD,CAMpE+J,QAASA,mBAAkB,EAAG,CAC1B,MAAOlB,YAAA,CAAYmB,KAAZ,CAAmBZ,MAAnB,CAA2B,CAC9B1B,KAAMN,KAAMC,CAAAA,OAAN,CAAcK,IAAd,CAAA,CAAsBA,IAAtB,CAA6ByB,aAAA,CAAcC,MAAd,CAAsB1B,IAAtB,CADL,CAA3B,CADmB,CAL9B,MAAM/C,MAAQ,CAAEC,KAAM,CAAA,CAAR,CAAeC,MAAOpB,IAAtB,CAAd,CACM2F,OAAShC,KAAMC,CAAAA,OAAN,CAAc7D,EAAd,CAAA,CAAoBA,EAApB,CAAyB,CAACC,IAAD,CAAOD,EAAP,CADxC,CAEMwG,MAAQL,oBAAA,CAAqBC,MAAA,EAAUA,MAAO9C,CAAAA,MAAjB,GAA4BsC,MAAOtC,CAAAA,MAAnC,CAC7B8C,MAD6B,CAE7BH,aAAA,CAAcL,MAAd,CAFQ,CAEepJ,QAFf,CAQd,KAAIkJ,aAAea,kBAAA,EACnB;MAAO,CACHhF,KAAOf,CAADe,EAAO,CACTJ,KAAME,CAAAA,KAAN,CAAcqE,YAAA,CAAalF,CAAb,CACdW,MAAMC,CAAAA,IAAN,CAAaZ,CAAb,EAAkBhE,QAClB,OAAO2E,MAHE,CADV,CAMHQ,WAAY,EAAAA,EAAM,CACdiE,MAAOH,CAAAA,OAAP,EACAC,aAAA,CAAea,kBAAA,EAFD,CANf,CAZ6D,CAyBxEE,QAASA,MAAK,CAAC,CAAE/J,QAAA,CAAW,CAAb,CAAgBuD,IAAA,CAAO,CAAvB,CAA0ByG,KAAA,CAAQ,EAAlC,CAAuCC,YAAA,CAAe,GAAtD,CAA2DxG,SAAA,CAAY,EAAvE,CAA4EyG,YAA5E,CAAD,CAA8F,CACxG,MAAMzF,MAAQ,CAAEC,KAAM,CAAA,CAAR,CAAeC,MAAOpB,IAAtB,CACd,KAAI4G,UAAYH,KAAZG,CAAoBnK,QAClBoK,SAAAA,CAAQ7G,IAAR6G,CAAeD,SACrB,OAAMnE,OAA0BxD,IAAAA,EAAjB,GAAA0H,YAAA,CAA6BE,QAA7B,CAAqCF,YAAA,CAAaE,QAAb,CAChDpE,OAAJ,GAAeoE,QAAf,GACID,SADJ,CACgBnE,MADhB,CACyBzC,IADzB,CAEA,OAAO,CACHsB,KAAOf,CAADe,EAAO,CACH1D,CAAAA,CAAQ,CAACgJ,SAAThJ,CAAqBL,IAAKE,CAAAA,GAAL,CAAS,CAAC8C,CAAV,CAAcmG,YAAd,CAC3BxF,MAAMC,CAAAA,IAAN,CAAa,EAAEvD,CAAF;AAAUsC,SAAV,EAAuBtC,CAAvB,CAA+B,CAACsC,SAAhC,CACbgB,MAAME,CAAAA,KAAN,CAAcF,KAAMC,CAAAA,IAAN,CAAasB,MAAb,CAAsBA,MAAtB,CAA+B7E,CAC7C,OAAOsD,MAJE,CADV,CAOHQ,WAAY,EAAAA,EAAM,EAPf,CAPiG,CAmB5GoF,QAASA,2BAA0B,CAACC,MAAD,CAAS,CACxC,GAAIpD,KAAMC,CAAAA,OAAN,CAAcmD,MAAOhH,CAAAA,EAArB,CAAJ,CACI,MAAOsG,UAEN,IAAIW,KAAA,CAAMD,MAAOE,CAAAA,IAAb,CAAJ,CACD,MAAOD,MAAA,CAAMD,MAAOE,CAAAA,IAAb,CAELnI,OAAAA,CAAO,IAAIoI,GAAJ,CAAQ9H,MAAON,CAAAA,IAAP,CAAYiI,MAAZ,CAAR,CACb,OAAIjI,OAAKqI,CAAAA,GAAL,CAAS,MAAT,CAAJ,EACKrI,MAAKqI,CAAAA,GAAL,CAAS,UAAT,CADL,EAC6B,CAACrI,MAAKqI,CAAAA,GAAL,CAAS,cAAT,CAD9B,EAIS,EAAArI,MAAKqI,CAAAA,GAAL,CAAS,cAAT,CAAA,EACLrI,MAAKqI,CAAAA,GAAL,CAAS,WAAT,CADK,EAELrI,MAAKqI,CAAAA,GAAL,CAAS,MAAT,CAFK,EAGLrI,MAAKqI,CAAAA,GAAL,CAAS,SAAT,CAHK,EAILrI,MAAKqI,CAAAA,GAAL,CAAS,WAAT,CAJK,EAKLrI,MAAKqI,CAAAA,GAAL,CAAS,WAAT,CALK,CAJT,CAYOd,SAZP;AAUW3G,MAlB6B,CAuB5C0H,QAASA,YAAW,CAACC,OAAD,CAAU9K,QAAV,CAAoB+K,KAAA,CAAQ,CAA5B,CAA+B,CAC/C,MAAOD,QAAP,CAAiB9K,QAAjB,CAA4B+K,KADmB,CAGnDC,QAASA,eAAc,CAACF,OAAD,CAAU9K,QAAV,CAAoB+K,KAAA,CAAQ,CAA5B,CAA+BE,iBAAA,CAAoB,CAAA,CAAnD,CAAyD,CAC5E,MAAOA,kBAAA,CACDJ,WAAA,CAAY7K,QAAZ,CAAuB,CAAC8K,OAAxB,CAAiC9K,QAAjC,CAA2C+K,KAA3C,CADC,CAED/K,QAFC,EAEW8K,OAFX,CAEqB9K,QAFrB,EAEiC+K,KAHoC,CAgBhFG,QAASA,QAAO,CAAC9H,EAAD,CAAK,CAsCjB+H,QAASA,OAAM,CAAC9J,KAAD,CAAQ,CACd4J,iBAAL,GACI5J,KADJ,CACY,CAACA,KADb,CAEAyJ,QAAA,EAAWzJ,KACN+J,WAAL,GACUzG,KAIN,CAJc0G,SAAUtG,CAAAA,IAAV,CAAe/D,IAAKsK,CAAAA,GAAL,CAAS,CAAT,CAAYR,OAAZ,CAAf,CAId,CAHAS,MAGA,CAHS5G,KAAME,CAAAA,KAGf,CAFI2G,qBAEJ,GADID,MACJ,CADaC,qBAAA,CAAsBD,MAAtB,CACb,EAAAH,UAAA,CAAaH,iBAAA;AAAoBtG,KAAMC,CAAAA,IAA1B,CAA4C,CAA5C,EAAiCkG,OALlD,CAOa,KAAb,GAAAW,QAAA,EAAkC,IAAK,EAAvC,GAAqBA,QAArB,CAA2C,IAAK,EAAhD,CAAoDA,QAAA,CAASF,MAAT,CACpD,IAAIH,UAAJ,CAGI,GAFoB,CAEhB,GAFAM,WAEA,GADqB,IAArB,GAAAC,gBAAA,EAAkD,IAAK,EAAvD,GAA6BA,gBAA7B,CAA2DA,gBAA3D,CAA+EA,gBAA/E,CAAkGb,OAClG,EAAAY,WAAA,CAAcE,SAAlB,CACI,IAA8DX,iBAhEnE,CAgE2BH,OAhE3B,EAgEoCa,gBAhEpC,CAgEsDE,WAhEtD,CAgE2Bf,OAhE3B,EAA6D,CAgEPe,WAAjD,CAjCRH,WAAA,EAWA,CAVmB,SAAnB,GAAII,UAAJ,EACIb,iBACA,CADwC,CACxC,GADoBS,WACpB,CADkC,CAClC,CAAAZ,OAAA,CAAUE,cAAA,CAAeF,OAAf,CAAwBa,gBAAxB,CAA0CE,WAA1C,CAAuDZ,iBAAvD,CAFd,GAKIH,OACA,CADUD,WAAA,CAAYC,OAAZ,CAAqBa,gBAArB;AAAuCE,WAAvC,CACV,CAAmB,QAAnB,GAAIC,UAAJ,EACIT,SAAUlG,CAAAA,UAAV,EAPR,CAUA,CADAiG,UACA,CADa,CAAA,CACb,CAAAW,QAAA,EAAYA,QAAA,EAsBJ,CADJ,IAlBJC,eAAeC,CAAAA,IAAf,EACA,CAAAC,UAAA,EAAcA,UAAA,EAEK,CArCvB,IAAQC,EAAR,CACI,CAAE1I,IAAF,CAAQ2I,QAAA,CAAW,CAAA,CAAnB,CAAyBC,MAAA,CAASC,SAAlC,CAA6CxB,OAAA,CAAU,CAAvD,CAA0D,OAAQc,SAAA,CAAY,CAA9E,CAAiFE,UAAA,CAAa,MAA9F,CAAsGD,WAAA,CAAc,CAApH,CAAuHU,MAAvH,CAA+HC,MAA/H,CAAuIN,UAAvI,CAAmJH,QAAnJ,CAA6JN,QAA7J,CAAA,CAA0KrI,EAAId,GAAAA,CAAUmC,KAAMC,CAAAA,MAAN,CAAatB,EAAb,CAAiB,uGAAA,CAAA,KAAA,CAAA,GAAA,CAAjB,CAC5L,KAAI,CAAEI,EAAF,CAAA,CAASlB,EAAb,CACI0J,cADJ,CAEIN,YAAc,CAFlB,CAGIC,iBAAmBrJ,EAAQtC,CAAAA,QAH/B;AAIIuL,MAJJ,CAKIH,WAAa,CAAA,CALjB,CAMIH,kBAAoB,CAAA,CANxB,CAOIO,qBACJ,OAAMiB,SAAWlC,0BAAA,CAA2BjI,EAA3B,CACjB,IAAkD,IAA9C,IAAC6J,EAAD,CAAYM,QAAUC,CAAAA,kBAAtB,GAA6D,IAAK,EAAlE,GAAsDP,EAAtD,CAAsE,CAAtE,CAA+EA,EAAGQ,CAAAA,IAAH,CAAnEF,QAAmE,CAAYhJ,IAAZ,CAAkBD,EAAlB,CAAnF,CACIgI,qBAIA,CAJwB3C,WAAA,CAAY,CAAC,CAAD,CAAI,GAAJ,CAAZ,CAAsB,CAACpF,IAAD,CAAOD,EAAP,CAAtB,CAAkC,CACtDhD,MAAO,CAAA,CAD+C,CAAlC,CAIxB,CADAiD,IACA,CADO,CACP,CAAAD,EAAA,CAAK,GAET,OAAM6H,UAAYoB,QAAA,CAAS5J,MAAOC,CAAAA,MAAP,CAAcD,MAAOC,CAAAA,MAAP,CAAc,EAAd,CAAkBR,EAAlB,CAAd,CAA0C,CAAEmB,IAAF,CAAQD,EAAR,CAA1C,CAAT,CA+ClB4I,SAAA,GAJe,IAAX,GAAAG,MAAA,EAA8B,IAAK,EAAnC,GAAmBA,MAAnB,CAAuC,IAAK,EAA5C,CAAgDA,MAAA,EAEhD,CADAP,cACA,CADiBK,MAAA,CAAOlB,MAAP,CACjB,CAAAa,cAAeY,CAAAA,KAAf,EAEJ,CACA,OAAO,CACHX,KAAM,EAAAA,EAAM,CACG,IAAX,GAAAO,MAAA,EAA8B,IAAK,EAAnC,GAAmBA,MAAnB;AAAuC,IAAK,EAA5C,CAAgDA,MAAA,EAChDR,eAAeC,CAAAA,IAAf,EAFQ,CADT,CAnEU,CA2ErBY,QAASA,kBAAiB,CAAC3M,QAAD,CAAW4M,aAAX,CAA0B,CAChD,MAAOA,cAAA,CAA4B,GAA5B,CAAmCA,aAAnC,CAAgB5M,QAAhB,CAAoD,CADX,CA5pBpD2C,MAAOkK,CAAAA,cAAP,CAAsBjN,OAAtB,CAA+B,YAA/B,CAA6C,CAAE+E,MAAO,CAAA,CAAT,CAA7C,CAEA,KAAIJ,MAAQ7E,OAAA,CAAQ,iCAAR,CAAZ,CACIS,UAAYT,OAAA,CAAQ,2CAAR,CADhB,CAEIwG,gBAAkBxG,OAAA,CAAQ,2DAAR,CAFtB,CAGIoN,KAAOpN,OAAA,CAAQ,yEAAR,CAHX,CAOIqN,cAAmDD,IAFX;AAAkB,QAAlB,GAAK,MAEMA,KAFX,EAA8B,SAA9B,EAEWA,KAFX,CAEWA,IAFX,CAAmD,CAAE,UAE1CA,IAFwC,CAI/F,OAAMxM,MAAQ,CAACoD,GAAD,CAAM0H,GAAN,CAAWnF,CAAX,CAAA3F,EAAiBQ,IAAK4C,CAAAA,GAAL,CAAS5C,IAAKsK,CAAAA,GAAL,CAASnF,CAAT,CAAYvC,GAAZ,CAAT,CAA2B0H,GAA3B,CAA/B,CA6EMrI,aAAe,CAAC,UAAD,CAAa,QAAb,CA7ErB,CA8EMD,YAAc,CAAC,WAAD,CAAc,SAAd,CAAyB,MAAzB,CA+GpBG,OAAOuJ,CAAAA,kBAAP,CAA4B,CAAC9K,CAAD,CAAIsL,CAAJ,CAAAC,EAAuB,QAAvBA,GAAU,MAAOvL,EAAjBuL,EAAgD,QAAhDA,GAAmC,MAAOD,EACtE,OAAMpI,KAAQsI,EAADtI,EAAQ,CAArB,CAEMuD,SAAW,CAAC5E,IAAD,CAAOD,EAAP,CAAWqB,KAAX,CAAAwD,EAAqB,CACT7E,EAAnB6J,EAAwB5J,IAC9B,OAA4B,EAArB,GAAA4J,EAAA,CAAyB,CAAzB,EAA8BxI,KAA9B,CAAsCpB,IAAtC,EAA8C4J,EAFnB,CAFtC,CAsDMC,WAAa,CAAClH,eAAgBmH,CAAAA,GAAjB,CAAsBnH,eAAgBoH,CAAAA,IAAtC,CAA4CpH,eAAgBqH,CAAAA,IAA5D,CAtDnB,CAuDMC,aAAgBvH,CAADuH,EAAOJ,UAAWK,CAAAA,IAAX,CAAiBjD,IAAD,EAAUA,IAAKpE,CAAAA,IAAL,CAAUH,CAAV,CAA1B,CAvD5B,CAwDMyH,cAAiBvH,KAADuH;AAAW,IAAIvH,KAAJ,sEAxDjC,CAyDME,SAAW,CAAC9C,aAAD,CAAOD,WAAP,CAAA+C,EAAc,CAC3B,IAAIsH,cAAgBH,YAAA,CAAajK,aAAb,CAApB,CACIqK,YAAcJ,YAAA,CAAalK,WAAb,CAClBnD,UAAU0I,CAAAA,SAAV,CAAoB,CAAC,CAAC8E,aAAtB,CAAqCD,aAAA,CAAcnK,aAAd,CAArC,CACApD,UAAU0I,CAAAA,SAAV,CAAoB,CAAC,CAAC+E,WAAtB,CAAmCF,aAAA,CAAcpK,WAAd,CAAnC,CACA,KAAIuK,UAAYF,aAAcjH,CAAAA,KAAd,CAAoBnD,aAApB,CAAhB,CACIuK,QAAUF,WAAYlH,CAAAA,KAAZ,CAAkBpD,WAAlB,CACVqK,cAAJ,GAAsBzH,eAAgBqH,CAAAA,IAAtC,GACIM,SACA,CADYxI,UAAA,CAAWwI,SAAX,CACZ,CAAAF,aAAA;AAAgBzH,eAAgBoH,CAAAA,IAFpC,CAIIM,YAAJ,GAAoB1H,eAAgBqH,CAAAA,IAApC,GACIO,OACA,CADUzI,UAAA,CAAWyI,OAAX,CACV,CAAAF,WAAA,CAAc1H,eAAgBoH,CAAAA,IAFlC,CAIA,OAAMS,QAAUpL,MAAOC,CAAAA,MAAP,CAAc,EAAd,CAAkBiL,SAAlB,CAChB,OAAQ5H,EAAD,EAAO,CACV,IAAK,MAAM1D,GAAX,GAAkBwL,QAAlB,CACI,GAAY,OAAZ,GAAIxL,GAAJ,CAAqB,CACa,IAAA,KAAAsL,SAAA,CAAUtL,GAAV,CAAA,CAAgB,GAAAuL,OAAA,CAAQvL,GAAR,CA1BzCgB,KAAXyK,EAAkBzK,IA0BZwK,QAAA,CAAQxL,GAAR,CAAA,CAxBLzB,IAAKC,CAAAA,IAAL,CAAUD,IAAKsK,CAAAA,GAAL,CAAS,CAAT,CAwBuDnF,CAxBvD,EADF3C,EACE,CADGA,EACH,CAA0B0K,IAA1B,EAAsCA,IAAtC,CAAV,CAuBsB,CAIKvI,EAAAA,CAAVoI,SAAUpI,CAAAA,KAA9BsI,QAAQtI,CAAAA,KAAR,CAxE4B,CAwEwBQ,CAApD,CAxEwC1C,EAwExC,CAAoD0C,CAApD,CAAqC6H,OAAQrI,CAAAA,KAA7C,CAxE+DlC,EAyE/D,OAAOoK,cAAcM,CAAAA,SAAd,CAAwBF,OAAxB,CAPG,CAhBa,CAzD/B,CAoFMG,UAAY,CACdC,EAAG,CADW,CAEdC,EAAG,CAFW,CAGdC,EAAG,CAHW,CApFlB,CA2FMrG,iBAAmB,CAACtG,CAAD,CAAIsL,CAAJ,CAAAhF,EAAW/B,CAAD,EAAO+G,CAAA,CAAEtL,CAAA,CAAEuE,CAAF,CAAF,CA3F1C,CAyGMmB,SAAW,CAAC7D,IAAD,CAAOD,EAAP,CAAA8D;AAAc,CAC3B,MAAMG,OAAS,CAAC,GAAGhE,IAAJ,CAAf,CACMoD,UAAYY,MAAOX,CAAAA,MADzB,CAEM0H,WAAa/K,IAAK6F,CAAAA,GAAL,CAAS,CAACmF,QAAD,CAAWvM,CAAX,CAAA,EAAiB8D,QAAA,CAASyI,QAAT,CAAmBjL,EAAA,CAAGtB,CAAH,CAAnB,CAA1B,CACnB,OAAQiE,EAAD,EAAO,CACV,IAAK,IAAIjE,EAAI,CAAb,CAAgBA,CAAhB,CAAoB2E,SAApB,CAA+B3E,CAAA,EAA/B,CACIuF,MAAA,CAAOvF,CAAP,CAAA,CAAYsM,UAAA,CAAWtM,CAAX,CAAA,CAAciE,CAAd,CAEhB,OAAOsB,OAJG,CAJa,CAzG/B,CAoHMF,UAAY,CAACtB,MAAD,CAASC,MAAT,CAAAqB,EAAoB,CAClC,MAAME,OAAS5E,MAAOC,CAAAA,MAAP,CAAcD,MAAOC,CAAAA,MAAP,CAAc,EAAd,CAAkBmD,MAAlB,CAAd,CAAyCC,MAAzC,CAAf,CACMsI,WAAa,EACnB,KAAK,MAAM/L,GAAX,GAAkBgF,OAAlB,CACwB/E,IAAAA,EAApB,GAAIuD,MAAA,CAAOxD,GAAP,CAAJ,EAAiDC,IAAAA,EAAjD,GAAiCwD,MAAA,CAAOzD,GAAP,CAAjC,GACI+L,UAAA,CAAW/L,GAAX,CADJ,CACsBuD,QAAA,CAASC,MAAA,CAAOxD,GAAP,CAAT,CAAsByD,MAAA,CAAOzD,GAAP,CAAtB,CADtB,CAIJ,OAAQ0D,EAAD,EAAO,CACV,IAAK,MAAM1D,GAAX,GAAkB+L,WAAlB,CACI/G,MAAA,CAAOhF,GAAP,CAAA,CAAc+L,UAAA,CAAW/L,GAAX,CAAA,CAAgB0D,CAAhB,CAElB,OAAOsB,OAJG,CARoB,CApHtC,CAwJMjB;AAAa,CAACP,MAAD,CAASC,MAAT,CAAAM,EAAoB,CACnC,MAAMkI,SAAWtI,eAAgBO,CAAAA,OAAQgI,CAAAA,iBAAxB,CAA0CzI,MAA1C,CAAjB,CACM0I,YAAcnI,OAAA,CAAQR,MAAR,CADpB,CAEM4I,YAAcpI,OAAA,CAAQP,MAAR,CAIpB,IAHuB0I,WAAY3H,CAAAA,MAGnC,GAH8C4H,WAAY5H,CAAAA,MAG1D,EAFI2H,WAAY5H,CAAAA,MAEhB,GAF2B6H,WAAY7H,CAAAA,MAEvC,EADI4H,WAAY7H,CAAAA,UAChB,EAD8B8H,WAAY9H,CAAAA,UAC1C,CACI,MAAY+H,CAAAxH,QAAA,CAASsH,WAAYlI,CAAAA,MAArB,CAA6BmI,WAAYnI,CAAAA,MAAzC,CAAAoI,CAAkDJ,QAAlDI,CApE2B7G,CAAAA,MAAb,CAAoBC,gBAApB,CAuE1B7H,UAAUC,CAAAA,OAAV,CAAkB,CAAA,CAAlB,CAAwB,mBAAmB2F,MAAnB,UAAmCC,MAAnC,0KAAxB,CACA;MAAQb,EAAD,EAAO,GAAO,CAAJ,CAAAA,CAAA,CAAQa,MAAR,CAAiBD,MAApB,EAZiB,CAxJvC,CAwKMkB,UAAY,CAAC1D,IAAD,CAAOD,EAAP,CAAA2D,EAAe9B,CAAD,EAjKI,CAiKiBA,CAArB,CAAW5B,IAAX,CAAqB4B,CAArB,CAAiB7B,EAAjB,CAAWC,IAkFrCsL,OAAAA,CAAgB1F,MAAA0F,EAAU1J,CAAA,EAAK,CAAL,CAASgE,MAAA,CAAO,CAAP,CAAWhE,CAAX,CACnC2J,QAAAA,CAAe3F,MAAA2F,EAAU3J,CAAA,EAAU,EAAL,EAAAA,CAAA,CAAWgE,MAAA,CAAO,CAAP,CAAWhE,CAAX,CAAX,CAA2B,CAA3B,EAAgC,CAAhC,CAAoCgE,MAAA,CAAO,CAAP,EAAY,CAAZ,CAAgBhE,CAAhB,EAApC,EAA2D,CACzF4J,OAAAA,CAAgB/E,KAAD+E,EAAW5J,CAAA,EAAKrE,IAAKQ,CAAAA,GAAL,CAAS6D,CAAT,CAAY6E,KAAZ,CACrC,OAAMgF,aAAgBhF,KAADgF,EAAW7J,CAAA,EAAKA,CAAL,CAASA,CAAT,GAAe6E,KAAf,CAAuB,CAAvB,EAA4B7E,CAA5B,CAAgC6E,KAAhC,CAAhC,CACMiF,iBAAoBjF,KAADiF,EAAW,CAChC,MAAMC,WAAaF,YAAA,CAAahF,KAAb,CACnB,OAAO7E,EAAA,EAAgB,CAAX,EAACA,CAAD,EAAM,CAAN,EACN,EADM,CACA+J,UAAA,CAAW/J,CAAX,CADA,CAEN,EAFM,EAEC,CAFD,CAEKrE,IAAKQ,CAAAA,GAAL,CAAS,CAAT,CAAY,CAAC,EAAb,EAAmB6D,CAAnB,CAAuB,CAAvB,EAFL,CAFoB,CADpC,CASMgK,uBAAyB,CAAzBA,CAA+B,EATrC,CAUMC,wBAA0B,CAA1BA,CAAgC,EAVtC,CAYMC,OAASlK,CAAAkK,EAAKlK,CAZpB,CAaMmK,OAASP,MAAA,CAAa,CAAb,CAbf,CAcMQ,QAAUV,MAAA,CAAcS,MAAd,CAdhB,CAeMjG;AAAYyF,OAAA,CAAaQ,MAAb,CAflB,CAgBME,OAASrK,CAAAqK,EAAK,CAALA,CAAS1O,IAAKiD,CAAAA,GAAL,CAASjD,IAAK2O,CAAAA,IAAL,CAAUtK,CAAV,CAAT,CAhBxB,CAiBMuK,QAAUb,MAAA,CAAcW,MAAd,CAjBhB,CAkBMG,UAAYb,OAAA,CAAaY,OAAb,CAlBlB,CAmBME,OAASZ,YAAA,CAXoBa,KAWpB,CAnBf,CAoBMC,QAAUjB,MAAA,CAAce,MAAd,CApBhB,CAqBMG,UAAYjB,OAAA,CAAac,MAAb,CArBlB,CAsBMI,WAAaf,gBAAA,CAdgBY,KAchB,CAtBnB,CAuBMI,GAAK,IAALA,CAAc,GAvBpB,CAwBMC,GAAK,KAALA,CAAe,IAxBrB,CAyBMC,GAAK,KAALA,CAAe,IAzBrB,CA0BMC,UAAajL,CAADiL,EAAO,CACrB,GAAU,CAAV,GAAIjL,CAAJ,EAAqB,CAArB,GAAeA,CAAf,CACI,MAAOA,EACX,OAAMkL,GAAKlL,CAALkL,CAASlL,CACf,OAAOA,EAAA,CAAIgK,sBAAJ,CACD,MADC,CACQkB,EADR,CAEDlL,CAAA,CAAIiK,uBAAJ,CACI,KADJ,CACYiB,EADZ,CACiB,GADjB,CACuBlL,CADvB,CAC2B,GAD3B,CArBqBmL,EAuBjB,CAAAnL,CAAA,CACI8K,EADJ,CACSI,EADT,CACcH,EADd,CACmB/K,CADnB,CACuBgL,EADvB,CAEI,IAFJ,CAEWhL,CAFX,CAEeA,CAFf,CAEmB,KAFnB,CAE2BA,CAF3B,CAE+B,KAVpB,CA1BzB,CAsCMoL,SAAW1B,MAAA,CAAcuB,SAAd,CAtCjB,CAgGM7F,MAAQ,CAAEX,SAAF,CAAa3G,MAAb,CAAqB8G,KAArB,CAhGd,CAoIMqC;AAAanB,MAADmB,EAAY,CAC1B,MAAMoE,cAAgB,CAAC,CAAErP,KAAF,CAAD,CAAAqP,EAAevF,MAAA,CAAO9J,KAAP,CACrC,OAAO,CACHuL,MAAO,EAAAA,EAAMK,aAAA,CAAc,SAAd,CAAyB9B,CAAAA,MAAzB,CAAgCuF,aAAhC,CAA+C,CAAA,CAA/C,CADV,CAEHzE,KAAM,EAAAA,EAAMe,IAAK2D,CAAAA,UAAWxF,CAAAA,MAAhB,CAAuBuF,aAAvB,CAFT,CAFmB,CApI9B,CA4SME,SAAYzK,CAADyK,EAAOzK,CA5SxB,CA6SM0K,gBAAkB,CAACC,iBAAA,CAAoBF,QAArB,CAAAC,EAAkC,CAACE,QAAD,CAAW9K,MAAX,CAAmBE,CAAnB,CAAA,EAAyB,CACzE6K,CAAAA,CAAe/K,MAAf+K,CAAwB7K,CACxB8K,SAAAA,CAA6B,EAAE,CAAF,CAAMF,QAAN,CAAiB,CAAjB,CAA7BE,EAAoD,CAApDA,CAAwDH,iBAAA,CAAkB9P,IAAK6C,CAAAA,GAAL,CAASmN,CAAT,CAAlB,CAAxDC,CACN,OAAuB,EAAhB,EAAAD,CAAA,CACD/K,MADC,CACQgL,QADR,CAEDhL,MAFC,CAEQgL,QALgE,CA7SnF,CAoTMC,QAAUL,eAAA,EApThB,CAqTMM,YAAcN,eAAA,CAAgB7P,IAAKC,CAAAA,IAArB,CArTpB,CAyTMmQ,QAAWC,KAADD,EAAWC,KAAMC,CAAAA,cAAN,CAAqB,GAArB,CAAXF,EAAwCC,KAAMC,CAAAA,cAAN,CAAqB,GAArB,CAzTxD;AA2TMC,UAAaF,KAADE,EAAWH,OAAA,CAAQC,KAAR,CAAXE,EAA6BF,KAAMC,CAAAA,cAAN,CAAqB,GAArB,CA3T/C,CAkVME,UAAY,CAACC,GAAD,CAAMC,SAAA,CAAY,CAAlB,CAAAF,EAAwB,CACtCE,SAAA,CAAY1Q,IAAKQ,CAAAA,GAAL,CAAS,EAAT,CAAakQ,SAAb,CACZ,OAAO1Q,KAAK+E,CAAAA,KAAL,CAAW0L,GAAX,CAAiBC,SAAjB,CAAP,CAAqCA,SAFC,CAlV1C,CAuVMC,YAAc,CAACC,SAAD,CAAYC,SAAZ,CAAuB7R,QAAvB,CAAiC8R,SAAA,CAAY,CAA7C,CAAAH,EAAmDH,SAAA,CAAUI,SAAV,CAClE5R,QADkE,EACtD6R,SADsD,CAC1CD,SAD0C,EAC5B5Q,IAAKsK,CAAAA,GAAL,CAASwG,SAAT,CAAoB9R,QAApB,CAD4B,CAvVvE,CA6YM+R,WAAa,CAAC/N,CAAD,CAAIgO,EAAJ,CAAQC,EAAR,CAAAF,KAHG,CAGHA,CAHS,CAGTA,CAAuBE,EAAvBF,CAHoB,CAGpBA,CAAmBC,EAAnBD,EAA6B/N,CAA7B+N,EAFG,CAEHA,CAAuCE,EAAvCF,CAFc,CAEdA,CAAmCC,EAAnCD,GAA8C/N,CAA9C+N,CADD,CACCA,CAAoDC,EAApDD,EAA2D/N,CA4E9ElE,QAAQoS,CAAAA,KAAR,CAjMc,CAACtQ,CAAD,CAAIsL,CAAA,CAAIkB,SAAR,CAAA8D,EAFmC,GAEnCA,CAAuClR,IAAKmR,CAAAA,KAALC,CAAWlF,CAAEoB,CAAAA,CAAb8D,CAAiBxQ,CAAE0M,CAAAA,CAAnB8D,CAAsBlF,CAAEmB,CAAAA,CAAxB+D,CAA4BxQ,CAAEyM,CAAAA,CAA9B+D,CAAvCF,CAF0ClR,IAAKqR,CAAAA,EAoM7DvS,QAAQoL,CAAAA,OAAR,CAAkBA,OAClBpL,QAAQoQ,CAAAA,UAAR,CAAqBA,UACrBpQ,QAAQwS,CAAAA,WAAR;AAlMoB,CAAC7O,IAAD,CAAOD,EAAP,CAAA8O,EAAc,CAC9B,IAAIC,gBAAkB,CAAA,CACX7P,KAAAA,EAAX,GAAIc,EAAJ,GACIA,EACA,CADKC,IACL,CAAA8O,eAAA,CAAkB,CAAA,CAFtB,CAIA,OAAQpM,EAAD,EAAO,CACV,GAAIoM,eAAJ,CACI,MAAOpM,EAAP,CAAW1C,IAAX,CAAkBD,EAGlBC,KAAA,CAAO0C,CACPoM,gBAAA,CAAkB,CAAA,CAClB,OAAO/O,GAPD,CANgB,CAmMlC1D,QAAQoR,CAAAA,OAAR,CAAkBA,OAClBpR,QAAQqR,CAAAA,WAAR,CAAsBA,WACtBrR,QAAQgQ,CAAAA,MAAR,CAAiBA,MACjBhQ,QAAQmQ,CAAAA,SAAR,CAAoBA,SACpBnQ,QAAQkQ,CAAAA,OAAR,CAAkBA,OAClBlQ,QAAQ2Q,CAAAA,QAAR,CAAmBA,QACnB3Q,QAAQ0S,CAAAA,WAAR,CA5bqBnN,CAADmN,EAAW,EAAJ,CAAAnN,CAAA,CACrB,EADqB,EACd,CADc,CACRiL,SAAA,CAAU,CAAV,CAAoB,CAApB,CAAgBjL,CAAhB,CADQ,EAErB,EAFqB,CAEfiL,SAAA,CAAc,CAAd,CAAUjL,CAAV,CAAoB,CAApB,CAFe,CAEY,EA2bvCvF,QAAQwQ,CAAAA,SAAR,CAAoBA,SACpBxQ,QAAQ4P,CAAAA,MAAR,CAAiBA,MACjB5P,QAAQ+P,CAAAA,SAAR,CAAoBA,SACpB/P,QAAQ8P,CAAAA,OAAR,CAAkBA,OAClB9P,QAAQU,CAAAA,KAAR;AAAgBA,KAChBV,QAAQqP,CAAAA,gBAAR,CAA2BA,gBAC3BrP,QAAQ+Q,CAAAA,eAAR,CAA0BA,eAC1B/Q,QAAQoP,CAAAA,YAAR,CAAuBA,YACvBpP,QAAQmP,CAAAA,YAAR,CAAuBA,MACvBnP,QAAQ2S,CAAAA,WAAR,CA5DAA,QAAoB,CAACC,GAAD,CAAMC,GAAN,CAAWC,GAAX,CAAgBC,GAAhB,CAAqB,CACrC,GAAIH,GAAJ,GAAYC,GAAZ,EAAmBC,GAAnB,GAA2BC,GAA3B,CACI,MAAOtD,OACX,OAAMuD,aAAe,IAAIC,YAAJ,CALAC,EAKA,CACrB,KAAK,IAAI9Q,EAAI,CAAb,CANqB8Q,EAMrB,CAAgB9Q,CAAhB,CAAsC,EAAEA,CAAxC,CACI4Q,YAAA,CAAa5Q,CAAb,CAAA,CAAkB6P,UAAA,CANFkB,EAME,CAAW/Q,CAAX,CAAgCwQ,GAAhC,CAAqCE,GAArC,CAwBtB,OAAQ5O,EAAD,EAAO,CAAA,GAAM,CAAN,GAAAA,CAAA,EAAiB,CAAjB,GAAWA,CAAX,CAAA,CAlBV,IAHA,IAAIkP,cAAgB,CAApB,CACIC,cAAgB,CAEpB,CADmBC,EACnB,GAAOD,aAAP,EAAuCL,YAAA,CAAaK,aAAb,CAAvC,EAkBmCE,CAlBnC,CAA0E,EAAEF,aAA5E,CACID,aAAA,EAbYD,EAehB,GAAEE,aAGIG;aAAAA,CAAYJ,aAAZI,EAY6BD,CAZ7BC,CAFaR,YAAA,CAAaK,aAAb,CAEbG,GADDR,YAAA,CAAaK,aAAb,CAA6B,CAA7B,CACCG,CADiCR,YAAA,CAAaK,aAAb,CACjCG,EAlBUL,EAmBhB,KAAMM,aArDkB,CAqDlBA,EAzDQ,CAyDRA,CAzDc,CAyDdA,CAAwCX,GAAxCW,CAzDyB,CAyDzBA,CAAmCb,GAAnCa,EAAwBD,aAAxBC,CAAwBD,aAAxBC,CArD4C,CAqD5CA,EAxDQ,CAwDRA,CAAwCX,GAAxCW,CAxDmB,CAwDnBA,CAAmCb,GAAnCa,EAAwBD,aAAxBC,CAvDI,CAuDJA,CAAmCb,GACzC,IAjCec,IAiCf,EAAID,YAAJ,CAAA,CA/BJ,IAASrR,aAAT,CAAa,CAAb,CAHqBuR,CAGrB,CAAgBvR,aAAhB,CAAsC,EAAEA,aAAxC,CAA2C,CACjCwR,YAAAA,CAxBkB,CAwBlBA,EA5BQ,CA4BRA,CA5Bc,CA4BdA,CA+BKd,GA/BLc,CA5ByB,CA4BzBA,CA+BKhB,GA/BLgB,EAAwBC,aAAxBD,CAAwBC,aAAxBD,CAxB4C,CAwB5CA,EA3BQ,CA2BRA,CA+BKd,GA/BLc,CA3BmB,CA2BnBA,CA+BKhB,GA/BLgB,EAAwBC,aAAxBD,CA1BI,CA0BJA,CA+BKhB,GA9BX,IAAqB,CAArB,GAAIgB,YAAJ,CACI,KAEJ,KAAME,SAAW7B,UAAA,CAAW4B,aAAX,CA2BNjB,GA3BM,CA2BNE,GA3BM,CAAXgB,CAoC6BP,CAnCnCM,cAAA,EAAWC,QAAX,CAAsBF,YANiB,CAQ3C,CAAA;AAAOC,aAuBH,CAAA,IAGK,IAAA,CAAA,GAAA,YAAA,CAAA,CAAA,CAAA,aAAA,KAAA,CAAA,aAAA,CAAA,aAAA,cAAA,EAvBW,EA5BpB,KAAIzR,EAAI,CACR,GACI2R,SAEA,CAFWC,aAEX,EAFiBC,aAEjB,CAFsBD,aAEtB,EAF4B,CAE5B,CADAF,YACA,CADW7B,UAAA,CAAW8B,QAAX,CAgDNnB,GAhDM,CAgDNE,GAhDM,CACX,CAsDmCS,CAtDnC,CAAe,CAAf,CAAIO,YAAJ,CACIG,aADJ,CACSF,QADT,CAIIC,aAJJ,CAISD,QAPb,OANyBG,IAMzB,CASShT,IAAK6C,CAAAA,GAAL,CAAS+P,YAAT,CATT,EAL6BK,EAK7B,CAUI,EAAE/R,CAVN,CAWA,EAAA,CAAO2R,QAuCE,CAO8B,CAAA,CAAA,UAAA,CAVnC,CAUmC,CAAA,GAAA,CAAA,GAAA,CAAzB,CAAA,MAAA,EAAA,CA7BuB,CA6DzC/T,QAAQmK,CAAAA,KAAR,CAAgBA,KAChBnK,QAAQoU,CAAAA,gBAAR,CAxL0BC,OAADD,EAAcC,OAAdD,CAAwBlT,IAAKqR,CAAAA,EAA7B6B,CAAmC,GAyL5DpU,QAAQsU,CAAAA,QAAR,CAlLAA,QAAiB,CAACxS,CAAD,CAAIsL,CAAJ,CAAO,CACpB,GAne8B,QAme9B,GAneiB,MAmePtL,EAAV,EAne8B,QAme9B;AAneiB,MAmeKsL,EAAtB,CACI,MAHqBlM,KAAK6C,CAAAA,GAAL,CAGHjC,CAHG,CAGAsL,CAHA,CAKpB,IAAIkE,OAAA,CAAQxP,CAAR,CAAJ,EAAkBwP,OAAA,CAAQlE,CAAR,CAAlB,CAA8B,CAC/B,MAAMmH,OANerT,IAAK6C,CAAAA,GAAL,CAMKjC,CAAEyM,CAAAA,CANP,CAMUnB,CAAEmB,CAAAA,CANZ,CAMrB,CACMiG,OAPetT,IAAK6C,CAAAA,GAAL,CAOKjC,CAAE0M,CAAAA,CAPP,CAOUpB,CAAEoB,CAAAA,CAPZ,CAQfiG,EAAAA,CAAShD,SAAA,CAAU3P,CAAV,CAAA,EAAgB2P,SAAA,CAAUrE,CAAV,CAAhB,CARMlM,IAAK6C,CAAAA,GAAL,CAQoCjC,CAAE2M,CAAAA,CARtC,CAQyCrB,CAAEqB,CAAAA,CAR3C,CAQN,CAAsD,CACrE,OAAOvN,KAAKC,CAAAA,IAAL,CAAUD,IAAKQ,CAAAA,GAAL,CAAS6S,MAAT,CAAiB,CAAjB,CAAV,CAAgCrT,IAAKQ,CAAAA,GAAL,CAAS8S,MAAT,CAAiB,CAAjB,CAAhC,CAAsDtT,IAAKQ,CAAAA,GAAL,CAAS+S,CAAT,CAAiB,CAAjB,CAAtD,CAJwB,CAJf,CAmLxBzU,QAAQ0P,CAAAA,MAAR,CAAiBA,MACjB1P,QAAQyJ,CAAAA,SAAR,CAAoBA,SACpBzJ,QAAQ2P,CAAAA,OAAR,CAAkBA,OAClB3P,QAAQ0U,CAAAA,OAAR,CA1RAA,QAAgB,CAAC,CAAE/Q,IAAA,CAAO,CAAT,CAAYvD,QAAA,CAAW,CAAvB,CAA0B0D,GAA1B,CAA+B0H,GAA/B,CAAoCpB,KAAA,CAAQ,EAA5C,CAAiDC,YAAA,CAAe,GAAhE,CAAqEsK,eAAA,CAAkB,GAAvF,CAA4FC,aAAA,CAAgB,EAA5G,CAAgH/Q,SAAA,CAAY,CAA5H,CAA+HyG,YAA/H,CAA6IiC,MAA7I,CAAqJZ,QAArJ,CAA+JS,UAA/J,CAA2KM,MAA3K,CAAD,CAAuL,CAKnMmI,QAASA,gBAAe,CAACxO,CAAD,CAAI,CACxB,MAAYzD,KAAAA,EAAZ;AAAIkB,GAAJ,CACW0H,GADX,CAEY5I,IAAAA,EAAZ,GAAI4I,GAAJ,CACW1H,GADX,CAEO5C,IAAK6C,CAAAA,GAAL,CAASD,GAAT,CAAeuC,CAAf,CAAA,CAAoBnF,IAAK6C,CAAAA,GAAL,CAASyH,GAAT,CAAenF,CAAf,CAApB,CAAwCvC,GAAxC,CAA8C0H,GAL7B,CAO5BsJ,QAASA,eAAc,CAACtS,OAAD,CAAU,CACR,IAArB,GAAAuS,gBAAA,EAAkD,IAAK,EAAvD,GAA6BA,gBAA7B,CAA2D,IAAK,EAAhE,CAAoEA,gBAAiB5I,CAAAA,IAAjB,EACpE4I,iBAAA,CAAmB3J,OAAA,CAAQrI,MAAOC,CAAAA,MAAP,CAAcD,MAAOC,CAAAA,MAAP,CAAc,EAAd,CAAkBR,OAAlB,CAAd,CAA0C,CAAE+J,MAAF,CAAUZ,SAAWtF,CAADsF,EAAO,CACxF,IAAIrI,EACS,KAAb,GAAAqI,QAAA,EAAkC,IAAK,EAAvC,GAAqBA,QAArB,CAA2C,IAAK,EAAhD,CAAoDA,QAAA,CAAStF,CAAT,CACxB,KAA5B,IAAC/C,EAAD,CAAMd,OAAQmJ,CAAAA,QAAd,GAA2C,IAAK,EAAhD,GAAoCrI,EAApC,CAAoD,IAAK,EAAzD,CAA6DA,EAAGuJ,CAAAA,IAAH,CAAQrK,OAAR,CAAiB6D,CAAjB,CAH2B,CAA3B,CAI9D+F,UAJ8D,CAKjEM,MALiE,CAA1C,CAAR,CAFU,CASjCsI,QAASA,YAAW,CAACxS,OAAD,CAAU,CAC1BsS,cAAA,CAAe/R,MAAOC,CAAAA,MAAP,CAAc,CAAE4H,KAAM,QAAR,CAAkB3I,UAAW0S,eAA7B;AAA8CzS,QAAS0S,aAAvD,CAAsE/Q,SAAtE,CAAd,CAAiGrB,OAAjG,CAAf,CAD0B,CApB9B,IAAIuS,gBAuBJ,IArBoBnS,IAAAA,EAqBpB,GArBYkB,GAqBZ,EAAkBH,IAAlB,CArBqCG,GAqBrC,EArBsDlB,IAAAA,EAqBtD,GArB8C4I,GAqB9C,EAAkB7H,IAAlB,CArBuE6H,GAqBvE,CACIwJ,WAAA,CAAY,CAAErR,IAAF,CAAQvD,QAAR,CAAkBsD,GAAImR,eAAA,CAAgBlR,IAAhB,CAAtB,CAAZ,CADJ,KAGK,CACD,IAAIyC,OAASgE,KAAThE,CAAiBhG,QAAjBgG,CAA4BzC,IACJ,YAA5B,GAAI,MAAO2G,aAAX,GACIlE,MADJ,CACakE,YAAA,CAAalE,MAAb,CADb,CAEA,OAAM6O,SAAWJ,eAAA,CAAgBzO,MAAhB,CAAjB,CACM8O,QAAUD,QAAA,GAAanR,GAAb,CAAmB,CAAC,CAApB,CAAwB,CACxC,KAAIqR,IAAJ,CACIjQ,OACJ,OAAMkQ,cAAiB/O,CAAD+O,EAAO,CACzBD,IAAA,CAAOjQ,OACPA,QAAA,CAAUmB,CACVjG,SAAA,CAAW2M,iBAAA,CAAkB1G,CAAlB,CAAsB8O,IAAtB,CAA4BjI,IAAKmI,CAAAA,YAAL,EAAoB9T,CAAAA,KAAhD,CACX,EAAiB,CAAjB,GAAK2T,OAAL,EAAsB7O,CAAtB,CAA0B4O,QAA1B,EACiB,CAAC,CADlB,GACKC,OADL;AACuB7O,CADvB,CAC2B4O,QAD3B,GAEID,WAAA,CAAY,CAAErR,KAAM0C,CAAR,CAAW3C,GAAIuR,QAAf,CAAyB7U,QAAzB,CAAZ,CANqB,CAS7B0U,eAAA,CAAe,CACXlK,KAAM,OADK,CAEXjH,IAFW,CAGXvD,QAHW,CAIXiK,YAJW,CAKXD,KALW,CAMXvG,SANW,CAOXyG,YAPW,CAQXqB,SAjDY/I,IAAAA,EAiDF,GAjDNkB,GAiDM,EAAcsC,MAAd,CAjDmBtC,GAiDnB,EAjDoClB,IAAAA,EAiDpC,GAjD4B4I,GAiD5B,EAAcpF,MAAd,CAjDqDoF,GAiDrD,CAAwB4J,aAAxB,CAAwCxS,IAAAA,EARvC,CAAf,CAjBC,CA4BL,MAAO,CACHuJ,KAAM,EAAAA,EAA2B,IAArB,GAAA4I,gBAAA,EAAkD,IAAK,EAAvD,GAA6BA,gBAA7B,CAA2D,IAAK,EAAhE,CAAoEA,gBAAiB5I,CAAAA,IAAjB,EAD7E,CAvD4L,CA2RvMnM,QAAQ+I,CAAAA,WAAR,CAAsBA,WACtB/I,QAAQsR,CAAAA,OAAR,CAAkBA,OAClBtR,QAAQyR,CAAAA,SAAR,CAAoBA,SACpBzR,QAAQgK,CAAAA,SAAR,CAAoBA,SACpBhK,QAAQyP,CAAAA,MAAR,CAAiBA,MACjBzP,QAAQkP,CAAAA,YAAR,CAAuBA,OACvBlP,QAAQsV,CAAAA,GAAR,CAjvBY,CAAC3R,IAAD;AAAOD,EAAP,CAAW6E,QAAX,CAAA+M,EAAwB,CAAC/M,QAAzB+M,CAAoC3R,IAApC2R,CAA2C/M,QAA3C+M,CAAsD5R,EAAtD4R,CAA2D3R,IAkvBvE3D,QAAQyG,CAAAA,QAAR,CAAmBA,QACnBzG,QAAQ0G,CAAAA,UAAR,CAAqBA,UACrB1G,QAAQuV,CAAAA,IAAR,CA/pBa,CAAC,GAAGvG,YAAJ,CAAAuG,EAAqBvG,YAAa7G,CAAAA,MAAb,CAAoBC,gBAApB,CAgqBlCpI,QAAQwV,CAAAA,eAAR,CArLwB,CAACrP,MAAD,CAASiM,KAAT,CAAgBkC,QAAhB,CAAAkB,EAA6B,CACjDpD,KAAA,CAAyBA,KAAzB,CApB6ClR,IAAKqR,CAAAA,EAoBlD,CApBwD,GAqBxD,OAAO,CACHhE,EAAG+F,QAAH/F,CAAcrN,IAAKkD,CAAAA,GAAL,CAASgO,KAAT,CAAd7D,CAAgCpI,MAAOoI,CAAAA,CADpC,CAEHC,EAAG8F,QAAH9F,CAActN,IAAKiD,CAAAA,GAAL,CAASiO,KAAT,CAAd5D,CAAgCrI,MAAOqI,CAAAA,CAFpC,CAF0C,CAsLrDxO,QAAQuI,CAAAA,QAAR,CAAmBA,QACnBvI,QAAQyV,CAAAA,gBAAR,CA3O0BnD,OAADmD,EAAwB,GAAxBA,CAAcnD,OAAdmD,CAA+BvU,IAAKqR,CAAAA,EA4O7DvS,QAAQiP,CAAAA,aAAR,CAAwBA,MACxBjP,QAAQ0V,CAAAA,MAAR,CAzKe,CAACC,QAAA,CAAW,EAAZ,CAAAD,EAAmB,CAC9B,IAAIE,cAAgB,CAApB,CACIC,YAAc,CAClB;MAAQxP,EAAD,EAAO,CACV,MAAMyP,kBAAoB5I,IAAKmI,CAAAA,YAAL,EAAoBU,CAAAA,SAA9C,CACMC,UAAYF,iBAAA,GAAsBD,WAAtB,CAAoCC,iBAApC,CAAwDD,WAAxD,CAAsE,CAClFI,EAAAA,CAAWD,SAAA,CACXnE,WAAA,CAAY+D,aAAZ,CAA2BvP,CAA3B,CAA8B2P,SAA9B,CAAyCL,QAAzC,CADW,CAEXC,aACNC,YAAA,CAAcC,iBAEd,OADAF,cACA,CADgBK,CAPN,CAHgB,CA0KlCjW,QAAQ6R,CAAAA,WAAR,CAAsBA,WACtB7R,QAAQkW,CAAAA,IAAR,CA5JcC,MAADD,EAAY,CACrB,GAAsB,QAAtB,GAAI,MAAOC,OAAX,CACI,MAAQ9P,EAAD,EAAOnF,IAAK+E,CAAAA,KAAL,CAAWI,CAAX,CAAe8P,MAAf,CAAP,CAAgCA,MAGvC,KAAI/T,EAAI,CACR,OAAMgU,UAAYD,MAAOnP,CAAAA,MACzB,OAAQX,EAAD,EAAO,CACV,IAAIgQ,aAAenV,IAAK6C,CAAAA,GAAL,CAASoS,MAAA,CAAO,CAAP,CAAT,CAAqB9P,CAArB,CACnB,KAAKjE,CAAL,CAAS,CAAT,CAAYA,CAAZ,CAAgBgU,SAAhB,CAA2BhU,CAAA,EAA3B,CAAgC,CAC5B,MAAMmP;AAAQ4E,MAAA,CAAO/T,CAAP,CAAd,CACMkS,SAAWpT,IAAK6C,CAAAA,GAAL,CAASwN,KAAT,CAAiBlL,CAAjB,CACjB,IAAiB,CAAjB,GAAIiO,QAAJ,CACI,MAAO/C,MACX,IAAI+C,QAAJ,CAAe+B,YAAf,CACI,MAAOF,OAAA,CAAO/T,CAAP,CAAW,CAAX,CACX,IAAIA,CAAJ,GAAUgU,SAAV,CAAsB,CAAtB,CACI,MAAO7E,MACX8E,aAAA,CAAe/B,QATa,CAFtB,CAPG,CA6JzBtU,QAAQqD,CAAAA,MAAR,CAAiBA,MACjBrD,QAAQsW,CAAAA,KAAR,CAtDc,CAACA,KAAD,CAAQC,SAAA,CAAY,KAApB,CAAAD,EAA+B/N,QAAD,EAAc,CACtDA,QAAA,CACkB,KAAd,GAAAgO,SAAA,CAAsBrV,IAAK4C,CAAAA,GAAL,CAASyE,QAAT,CAAmB,IAAnB,CAAtB,CAAkDrH,IAAKsK,CAAAA,GAAL,CAASjD,QAAT,CAAmB,IAAnB,CACrCA,SAAXiO,EAAsBF,KAE5B,OAAO5V,MAAA,CAAM,CAAN,CAAS,CAAT,EADuB,KAAd+V,GAAAF,SAAAE,CAAsBvV,IAAKwV,CAAAA,KAAL,CAAWF,QAAX,CAAtBC,CAA6CvV,IAAKyV,CAAAA,IAAL,CAAUH,QAAV,CACtD,EAAsBF,KAAtB,CAL+C,CAuD1DtW,QAAQ0R,CAAAA,SAAR,CAAoBA,SACpB1R,QAAQ4W,CAAAA,gBAAR,CAxIAA,QAAyB,CAACC,GAAD,CAAM7J,aAAN,CAAqB,CAC1C,MAAO6J,IAAP;CAAc,GAAd,CAAqB7J,aAArB,CAD0C,CAyI9ChN,QAAQ+M,CAAAA,iBAAR,CAA4BA,iBAC5B/M,QAAQ8W,CAAAA,IAAR,CAtIa,CAAChT,GAAD,CAAM0H,GAAN,CAAWnF,CAAX,CAAAyQ,EAAiB,CACRtL,GAAZuL,EAAkBjT,GACxB,SAAWuC,CAAX,CAAevC,GAAf,EAAsBiT,GAAtB,CAAmCA,GAAnC,EAAgDA,GAAhD,CAA6DjT,GAFnC,CA90B+E;\",\n\"sources\":[\"node_modules/popmotion/dist/popmotion.cjs.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$popmotion$dist$popmotion_cjs\\\"] = function(global,require,module,exports) {\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', { value: true });\\n\\nvar tslib = require('tslib');\\nvar heyListen = require('hey-listen');\\nvar styleValueTypes = require('style-value-types');\\nvar sync = require('framesync');\\n\\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\\n\\nvar sync__default = /*#__PURE__*/_interopDefaultLegacy(sync);\\n\\nconst clamp = (min, max, v) => Math.min(Math.max(v, min), max);\\n\\nconst safeMin = 0.001;\\nconst minDuration = 0.01;\\nconst maxDuration = 10.0;\\nconst minDamping = 0.05;\\nconst maxDamping = 1;\\nfunction findSpring({ duration = 800, bounce = 0.25, velocity = 0, mass = 1, }) {\\n    let envelope;\\n    let derivative;\\n    heyListen.warning(duration <= maxDuration * 1000, \\\"Spring duration must be 10 seconds or less\\\");\\n    let dampingRatio = 1 - bounce;\\n    dampingRatio = clamp(minDamping, maxDamping, dampingRatio);\\n    duration = clamp(minDuration, maxDuration, duration / 1000);\\n    if (dampingRatio < 1) {\\n        envelope = (undampedFreq) => {\\n            const exponentialDecay = undampedFreq * dampingRatio;\\n            const delta = exponentialDecay * duration;\\n            const a = exponentialDecay - velocity;\\n            const b = calcAngularFreq(undampedFreq, dampingRatio);\\n            const c = Math.exp(-delta);\\n            return safeMin - (a / b) * c;\\n        };\\n        derivative = (undampedFreq) => {\\n            const exponentialDecay = undampedFreq * dampingRatio;\\n            const delta = exponentialDecay * duration;\\n            const d = delta * velocity + velocity;\\n            const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq, 2) * duration;\\n            const f = Math.exp(-delta);\\n            const g = calcAngularFreq(Math.pow(undampedFreq, 2), dampingRatio);\\n            const factor = -envelope(undampedFreq) + safeMin > 0 ? -1 : 1;\\n            return (factor * ((d - e) * f)) / g;\\n        };\\n    }\\n    else {\\n        envelope = (undampedFreq) => {\\n            const a = Math.exp(-undampedFreq * duration);\\n            const b = (undampedFreq - velocity) * duration + 1;\\n            return -safeMin + a * b;\\n        };\\n        derivative = (undampedFreq) => {\\n            const a = Math.exp(-undampedFreq * duration);\\n            const b = (velocity - undampedFreq) * (duration * duration);\\n            return a * b;\\n        };\\n    }\\n    const initialGuess = 5 / duration;\\n    const undampedFreq = approximateRoot(envelope, derivative, initialGuess);\\n    duration = duration * 1000;\\n    if (isNaN(undampedFreq)) {\\n        return {\\n            stiffness: 100,\\n            damping: 10,\\n            duration,\\n        };\\n    }\\n    else {\\n        const stiffness = Math.pow(undampedFreq, 2) * mass;\\n        return {\\n            stiffness,\\n            damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),\\n            duration,\\n        };\\n    }\\n}\\nconst rootIterations = 12;\\nfunction approximateRoot(envelope, derivative, initialGuess) {\\n    let result = initialGuess;\\n    for (let i = 1; i < rootIterations; i++) {\\n        result = result - envelope(result) / derivative(result);\\n    }\\n    return result;\\n}\\nfunction calcAngularFreq(undampedFreq, dampingRatio) {\\n    return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);\\n}\\n\\nconst durationKeys = [\\\"duration\\\", \\\"bounce\\\"];\\nconst physicsKeys = [\\\"stiffness\\\", \\\"damping\\\", \\\"mass\\\"];\\nfunction isSpringType(options, keys) {\\n    return keys.some((key) => options[key] !== undefined);\\n}\\nfunction getSpringOptions(options) {\\n    let springOptions = Object.assign({ velocity: 0.0, stiffness: 100, damping: 10, mass: 1.0, isResolvedFromDuration: false }, options);\\n    if (!isSpringType(options, physicsKeys) &&\\n        isSpringType(options, durationKeys)) {\\n        const derived = findSpring(options);\\n        springOptions = Object.assign(Object.assign(Object.assign({}, springOptions), derived), { velocity: 0.0, mass: 1.0 });\\n        springOptions.isResolvedFromDuration = true;\\n    }\\n    return springOptions;\\n}\\nfunction spring(_a) {\\n    var { from = 0.0, to = 1.0, restSpeed = 2, restDelta } = _a, options = tslib.__rest(_a, [\\\"from\\\", \\\"to\\\", \\\"restSpeed\\\", \\\"restDelta\\\"]);\\n    const state = { done: false, value: from };\\n    let { stiffness, damping, mass, velocity, duration, isResolvedFromDuration, } = getSpringOptions(options);\\n    let resolveSpring = zero;\\n    let resolveVelocity = zero;\\n    function createSpring() {\\n        const initialVelocity = velocity ? -(velocity / 1000) : 0.0;\\n        const initialDelta = to - from;\\n        const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\\n        const undampedAngularFreq = Math.sqrt(stiffness / mass) / 1000;\\n        if (restDelta === undefined) {\\n            restDelta = Math.min(Math.abs(to - from) / 100, 0.4);\\n        }\\n        if (dampingRatio < 1) {\\n            const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\\n            resolveSpring = (t) => {\\n                const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\\n                return (to -\\n                    envelope *\\n                        (((initialVelocity +\\n                            dampingRatio * undampedAngularFreq * initialDelta) /\\n                            angularFreq) *\\n                            Math.sin(angularFreq * t) +\\n                            initialDelta * Math.cos(angularFreq * t)));\\n            };\\n            resolveVelocity = (t) => {\\n                const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\\n                return (dampingRatio *\\n                    undampedAngularFreq *\\n                    envelope *\\n                    ((Math.sin(angularFreq * t) *\\n                        (initialVelocity +\\n                            dampingRatio *\\n                                undampedAngularFreq *\\n                                initialDelta)) /\\n                        angularFreq +\\n                        initialDelta * Math.cos(angularFreq * t)) -\\n                    envelope *\\n                        (Math.cos(angularFreq * t) *\\n                            (initialVelocity +\\n                                dampingRatio *\\n                                    undampedAngularFreq *\\n                                    initialDelta) -\\n                            angularFreq *\\n                                initialDelta *\\n                                Math.sin(angularFreq * t)));\\n            };\\n        }\\n        else if (dampingRatio === 1) {\\n            resolveSpring = (t) => to -\\n                Math.exp(-undampedAngularFreq * t) *\\n                    (initialDelta +\\n                        (initialVelocity + undampedAngularFreq * initialDelta) *\\n                            t);\\n        }\\n        else {\\n            const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\\n            resolveSpring = (t) => {\\n                const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\\n                const freqForT = Math.min(dampedAngularFreq * t, 300);\\n                return (to -\\n                    (envelope *\\n                        ((initialVelocity +\\n                            dampingRatio * undampedAngularFreq * initialDelta) *\\n                            Math.sinh(freqForT) +\\n                            dampedAngularFreq *\\n                                initialDelta *\\n                                Math.cosh(freqForT))) /\\n                        dampedAngularFreq);\\n            };\\n        }\\n    }\\n    createSpring();\\n    return {\\n        next: (t) => {\\n            const current = resolveSpring(t);\\n            if (!isResolvedFromDuration) {\\n                const currentVelocity = resolveVelocity(t) * 1000;\\n                const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\\n                const isBelowDisplacementThreshold = Math.abs(to - current) <= restDelta;\\n                state.done =\\n                    isBelowVelocityThreshold && isBelowDisplacementThreshold;\\n            }\\n            else {\\n                state.done = t >= duration;\\n            }\\n            state.value = state.done ? to : current;\\n            return state;\\n        },\\n        flipTarget: () => {\\n            velocity = -velocity;\\n            [from, to] = [to, from];\\n            createSpring();\\n        },\\n    };\\n}\\nspring.needsInterpolation = (a, b) => typeof a === \\\"string\\\" || typeof b === \\\"string\\\";\\nconst zero = (_t) => 0;\\n\\nconst progress = (from, to, value) => {\\n    const toFromDifference = to - from;\\n    return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;\\n};\\n\\nconst mix = (from, to, progress) => -progress * from + progress * to + from;\\n\\nfunction hueToRgb(p, q, t) {\\n    if (t < 0)\\n        t += 1;\\n    if (t > 1)\\n        t -= 1;\\n    if (t < 1 / 6)\\n        return p + (q - p) * 6 * t;\\n    if (t < 1 / 2)\\n        return q;\\n    if (t < 2 / 3)\\n        return p + (q - p) * (2 / 3 - t) * 6;\\n    return p;\\n}\\nfunction hslaToRgba({ hue, saturation, lightness, alpha }) {\\n    hue /= 360;\\n    saturation /= 100;\\n    lightness /= 100;\\n    let red = 0;\\n    let green = 0;\\n    let blue = 0;\\n    if (!saturation) {\\n        red = green = blue = lightness;\\n    }\\n    else {\\n        const q = lightness < 0.5\\n            ? lightness * (1 + saturation)\\n            : lightness + saturation - lightness * saturation;\\n        const p = 2 * lightness - q;\\n        red = hueToRgb(p, q, hue + 1 / 3);\\n        green = hueToRgb(p, q, hue);\\n        blue = hueToRgb(p, q, hue - 1 / 3);\\n    }\\n    return {\\n        red: Math.round(red * 255),\\n        green: Math.round(green * 255),\\n        blue: Math.round(blue * 255),\\n        alpha,\\n    };\\n}\\n\\nconst mixLinearColor = (from, to, v) => {\\n    const fromExpo = from * from;\\n    const toExpo = to * to;\\n    return Math.sqrt(Math.max(0, v * (toExpo - fromExpo) + fromExpo));\\n};\\nconst colorTypes = [styleValueTypes.hex, styleValueTypes.rgba, styleValueTypes.hsla];\\nconst getColorType = (v) => colorTypes.find((type) => type.test(v));\\nconst notAnimatable = (color) => `'${color}' is not an animatable color. Use the equivalent color code instead.`;\\nconst mixColor = (from, to) => {\\n    let fromColorType = getColorType(from);\\n    let toColorType = getColorType(to);\\n    heyListen.invariant(!!fromColorType, notAnimatable(from));\\n    heyListen.invariant(!!toColorType, notAnimatable(to));\\n    let fromColor = fromColorType.parse(from);\\n    let toColor = toColorType.parse(to);\\n    if (fromColorType === styleValueTypes.hsla) {\\n        fromColor = hslaToRgba(fromColor);\\n        fromColorType = styleValueTypes.rgba;\\n    }\\n    if (toColorType === styleValueTypes.hsla) {\\n        toColor = hslaToRgba(toColor);\\n        toColorType = styleValueTypes.rgba;\\n    }\\n    const blended = Object.assign({}, fromColor);\\n    return (v) => {\\n        for (const key in blended) {\\n            if (key !== \\\"alpha\\\") {\\n                blended[key] = mixLinearColor(fromColor[key], toColor[key], v);\\n            }\\n        }\\n        blended.alpha = mix(fromColor.alpha, toColor.alpha, v);\\n        return fromColorType.transform(blended);\\n    };\\n};\\n\\nconst zeroPoint = {\\n    x: 0,\\n    y: 0,\\n    z: 0\\n};\\nconst isNum = (v) => typeof v === 'number';\\n\\nconst combineFunctions = (a, b) => (v) => b(a(v));\\nconst pipe = (...transformers) => transformers.reduce(combineFunctions);\\n\\nfunction getMixer(origin, target) {\\n    if (isNum(origin)) {\\n        return (v) => mix(origin, target, v);\\n    }\\n    else if (styleValueTypes.color.test(origin)) {\\n        return mixColor(origin, target);\\n    }\\n    else {\\n        return mixComplex(origin, target);\\n    }\\n}\\nconst mixArray = (from, to) => {\\n    const output = [...from];\\n    const numValues = output.length;\\n    const blendValue = from.map((fromThis, i) => getMixer(fromThis, to[i]));\\n    return (v) => {\\n        for (let i = 0; i < numValues; i++) {\\n            output[i] = blendValue[i](v);\\n        }\\n        return output;\\n    };\\n};\\nconst mixObject = (origin, target) => {\\n    const output = Object.assign(Object.assign({}, origin), target);\\n    const blendValue = {};\\n    for (const key in output) {\\n        if (origin[key] !== undefined && target[key] !== undefined) {\\n            blendValue[key] = getMixer(origin[key], target[key]);\\n        }\\n    }\\n    return (v) => {\\n        for (const key in blendValue) {\\n            output[key] = blendValue[key](v);\\n        }\\n        return output;\\n    };\\n};\\nfunction analyse(value) {\\n    const parsed = styleValueTypes.complex.parse(value);\\n    const numValues = parsed.length;\\n    let numNumbers = 0;\\n    let numRGB = 0;\\n    let numHSL = 0;\\n    for (let i = 0; i < numValues; i++) {\\n        if (numNumbers || typeof parsed[i] === \\\"number\\\") {\\n            numNumbers++;\\n        }\\n        else {\\n            if (parsed[i].hue !== undefined) {\\n                numHSL++;\\n            }\\n            else {\\n                numRGB++;\\n            }\\n        }\\n    }\\n    return { parsed, numNumbers, numRGB, numHSL };\\n}\\nconst mixComplex = (origin, target) => {\\n    const template = styleValueTypes.complex.createTransformer(target);\\n    const originStats = analyse(origin);\\n    const targetStats = analyse(target);\\n    const canInterpolate = originStats.numHSL === targetStats.numHSL &&\\n        originStats.numRGB === targetStats.numRGB &&\\n        originStats.numNumbers >= targetStats.numNumbers;\\n    if (canInterpolate) {\\n        return pipe(mixArray(originStats.parsed, targetStats.parsed), template);\\n    }\\n    else {\\n        heyListen.warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);\\n        return (p) => `${p > 0 ? target : origin}`;\\n    }\\n};\\n\\nconst mixNumber = (from, to) => (p) => mix(from, to, p);\\nfunction detectMixerFactory(v) {\\n    if (typeof v === 'number') {\\n        return mixNumber;\\n    }\\n    else if (typeof v === 'string') {\\n        if (styleValueTypes.color.test(v)) {\\n            return mixColor;\\n        }\\n        else {\\n            return mixComplex;\\n        }\\n    }\\n    else if (Array.isArray(v)) {\\n        return mixArray;\\n    }\\n    else if (typeof v === 'object') {\\n        return mixObject;\\n    }\\n}\\nfunction createMixers(output, ease, customMixer) {\\n    const mixers = [];\\n    const mixerFactory = customMixer || detectMixerFactory(output[0]);\\n    const numMixers = output.length - 1;\\n    for (let i = 0; i < numMixers; i++) {\\n        let mixer = mixerFactory(output[i], output[i + 1]);\\n        if (ease) {\\n            const easingFunction = Array.isArray(ease) ? ease[i] : ease;\\n            mixer = pipe(easingFunction, mixer);\\n        }\\n        mixers.push(mixer);\\n    }\\n    return mixers;\\n}\\nfunction fastInterpolate([from, to], [mixer]) {\\n    return (v) => mixer(progress(from, to, v));\\n}\\nfunction slowInterpolate(input, mixers) {\\n    const inputLength = input.length;\\n    const lastInputIndex = inputLength - 1;\\n    return (v) => {\\n        let mixerIndex = 0;\\n        let foundMixerIndex = false;\\n        if (v <= input[0]) {\\n            foundMixerIndex = true;\\n        }\\n        else if (v >= input[lastInputIndex]) {\\n            mixerIndex = lastInputIndex - 1;\\n            foundMixerIndex = true;\\n        }\\n        if (!foundMixerIndex) {\\n            let i = 1;\\n            for (; i < inputLength; i++) {\\n                if (input[i] > v || i === lastInputIndex) {\\n                    break;\\n                }\\n            }\\n            mixerIndex = i - 1;\\n        }\\n        const progressInRange = progress(input[mixerIndex], input[mixerIndex + 1], v);\\n        return mixers[mixerIndex](progressInRange);\\n    };\\n}\\nfunction interpolate(input, output, { clamp: isClamp = true, ease, mixer } = {}) {\\n    const inputLength = input.length;\\n    heyListen.invariant(inputLength === output.length, 'Both input and output ranges must be the same length');\\n    heyListen.invariant(!ease || !Array.isArray(ease) || ease.length === inputLength - 1, 'Array of easing functions must be of length `input.length - 1`, as it applies to the transitions **between** the defined values.');\\n    if (input[0] > input[inputLength - 1]) {\\n        input = [].concat(input);\\n        output = [].concat(output);\\n        input.reverse();\\n        output.reverse();\\n    }\\n    const mixers = createMixers(output, ease, mixer);\\n    const interpolator = inputLength === 2\\n        ? fastInterpolate(input, mixers)\\n        : slowInterpolate(input, mixers);\\n    return isClamp\\n        ? (v) => interpolator(clamp(input[0], input[inputLength - 1], v))\\n        : interpolator;\\n}\\n\\nconst reverseEasing = easing => p => 1 - easing(1 - p);\\nconst mirrorEasing = easing => p => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;\\nconst createExpoIn = (power) => p => Math.pow(p, power);\\nconst createBackIn = (power) => p => p * p * ((power + 1) * p - power);\\nconst createAnticipate = (power) => {\\n    const backEasing = createBackIn(power);\\n    return p => (p *= 2) < 1\\n        ? 0.5 * backEasing(p)\\n        : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));\\n};\\n\\nconst DEFAULT_OVERSHOOT_STRENGTH = 1.525;\\nconst BOUNCE_FIRST_THRESHOLD = 4.0 / 11.0;\\nconst BOUNCE_SECOND_THRESHOLD = 8.0 / 11.0;\\nconst BOUNCE_THIRD_THRESHOLD = 9.0 / 10.0;\\nconst linear = p => p;\\nconst easeIn = createExpoIn(2);\\nconst easeOut = reverseEasing(easeIn);\\nconst easeInOut = mirrorEasing(easeIn);\\nconst circIn = p => 1 - Math.sin(Math.acos(p));\\nconst circOut = reverseEasing(circIn);\\nconst circInOut = mirrorEasing(circOut);\\nconst backIn = createBackIn(DEFAULT_OVERSHOOT_STRENGTH);\\nconst backOut = reverseEasing(backIn);\\nconst backInOut = mirrorEasing(backIn);\\nconst anticipate = createAnticipate(DEFAULT_OVERSHOOT_STRENGTH);\\nconst ca = 4356.0 / 361.0;\\nconst cb = 35442.0 / 1805.0;\\nconst cc = 16061.0 / 1805.0;\\nconst bounceOut = (p) => {\\n    if (p === 1 || p === 0)\\n        return p;\\n    const p2 = p * p;\\n    return p < BOUNCE_FIRST_THRESHOLD\\n        ? 7.5625 * p2\\n        : p < BOUNCE_SECOND_THRESHOLD\\n            ? 9.075 * p2 - 9.9 * p + 3.4\\n            : p < BOUNCE_THIRD_THRESHOLD\\n                ? ca * p2 - cb * p + cc\\n                : 10.8 * p * p - 20.52 * p + 10.72;\\n};\\nconst bounceIn = reverseEasing(bounceOut);\\nconst bounceInOut = (p) => p < 0.5\\n    ? 0.5 * (1.0 - bounceOut(1.0 - p * 2.0))\\n    : 0.5 * bounceOut(p * 2.0 - 1.0) + 0.5;\\n\\nfunction defaultEasing(values, easing) {\\n    return values.map(() => easing || easeInOut).splice(0, values.length - 1);\\n}\\nfunction defaultOffset(values) {\\n    const numValues = values.length;\\n    return values.map((_value, i) => i !== 0 ? i / (numValues - 1) : 0);\\n}\\nfunction convertOffsetToTimes(offset, duration) {\\n    return offset.map((o) => o * duration);\\n}\\nfunction keyframes({ from = 0, to = 1, ease, offset, duration = 300, }) {\\n    const state = { done: false, value: from };\\n    const values = Array.isArray(to) ? to : [from, to];\\n    const times = convertOffsetToTimes(offset && offset.length === values.length\\n        ? offset\\n        : defaultOffset(values), duration);\\n    function createInterpolator() {\\n        return interpolate(times, values, {\\n            ease: Array.isArray(ease) ? ease : defaultEasing(values, ease),\\n        });\\n    }\\n    let interpolator = createInterpolator();\\n    return {\\n        next: (t) => {\\n            state.value = interpolator(t);\\n            state.done = t >= duration;\\n            return state;\\n        },\\n        flipTarget: () => {\\n            values.reverse();\\n            interpolator = createInterpolator();\\n        },\\n    };\\n}\\n\\nfunction decay({ velocity = 0, from = 0, power = 0.8, timeConstant = 350, restDelta = 0.5, modifyTarget, }) {\\n    const state = { done: false, value: from };\\n    let amplitude = power * velocity;\\n    const ideal = from + amplitude;\\n    const target = modifyTarget === undefined ? ideal : modifyTarget(ideal);\\n    if (target !== ideal)\\n        amplitude = target - from;\\n    return {\\n        next: (t) => {\\n            const delta = -amplitude * Math.exp(-t / timeConstant);\\n            state.done = !(delta > restDelta || delta < -restDelta);\\n            state.value = state.done ? target : target + delta;\\n            return state;\\n        },\\n        flipTarget: () => { },\\n    };\\n}\\n\\nconst types = { keyframes, spring, decay };\\nfunction detectAnimationFromOptions(config) {\\n    if (Array.isArray(config.to)) {\\n        return keyframes;\\n    }\\n    else if (types[config.type]) {\\n        return types[config.type];\\n    }\\n    const keys = new Set(Object.keys(config));\\n    if (keys.has(\\\"ease\\\") ||\\n        (keys.has(\\\"duration\\\") && !keys.has(\\\"dampingRatio\\\"))) {\\n        return keyframes;\\n    }\\n    else if (keys.has(\\\"dampingRatio\\\") ||\\n        keys.has(\\\"stiffness\\\") ||\\n        keys.has(\\\"mass\\\") ||\\n        keys.has(\\\"damping\\\") ||\\n        keys.has(\\\"restSpeed\\\") ||\\n        keys.has(\\\"restDelta\\\")) {\\n        return spring;\\n    }\\n    return keyframes;\\n}\\n\\nfunction loopElapsed(elapsed, duration, delay = 0) {\\n    return elapsed - duration - delay;\\n}\\nfunction reverseElapsed(elapsed, duration, delay = 0, isForwardPlayback = true) {\\n    return isForwardPlayback\\n        ? loopElapsed(duration + -elapsed, duration, delay)\\n        : duration - (elapsed - duration) + delay;\\n}\\nfunction hasRepeatDelayElapsed(elapsed, duration, delay, isForwardPlayback) {\\n    return isForwardPlayback ? elapsed >= duration + delay : elapsed <= -delay;\\n}\\n\\nconst framesync = (update) => {\\n    const passTimestamp = ({ delta }) => update(delta);\\n    return {\\n        start: () => sync__default[\\\"default\\\"].update(passTimestamp, true),\\n        stop: () => sync.cancelSync.update(passTimestamp),\\n    };\\n};\\nfunction animate(_a) {\\n    var _b, _c;\\n    var { from, autoplay = true, driver = framesync, elapsed = 0, repeat: repeatMax = 0, repeatType = \\\"loop\\\", repeatDelay = 0, onPlay, onStop, onComplete, onRepeat, onUpdate } = _a, options = tslib.__rest(_a, [\\\"from\\\", \\\"autoplay\\\", \\\"driver\\\", \\\"elapsed\\\", \\\"repeat\\\", \\\"repeatType\\\", \\\"repeatDelay\\\", \\\"onPlay\\\", \\\"onStop\\\", \\\"onComplete\\\", \\\"onRepeat\\\", \\\"onUpdate\\\"]);\\n    let { to } = options;\\n    let driverControls;\\n    let repeatCount = 0;\\n    let computedDuration = options.duration;\\n    let latest;\\n    let isComplete = false;\\n    let isForwardPlayback = true;\\n    let interpolateFromNumber;\\n    const animator = detectAnimationFromOptions(options);\\n    if ((_c = (_b = animator).needsInterpolation) === null || _c === void 0 ? void 0 : _c.call(_b, from, to)) {\\n        interpolateFromNumber = interpolate([0, 100], [from, to], {\\n            clamp: false,\\n        });\\n        from = 0;\\n        to = 100;\\n    }\\n    const animation = animator(Object.assign(Object.assign({}, options), { from, to }));\\n    function repeat() {\\n        repeatCount++;\\n        if (repeatType === \\\"reverse\\\") {\\n            isForwardPlayback = repeatCount % 2 === 0;\\n            elapsed = reverseElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback);\\n        }\\n        else {\\n            elapsed = loopElapsed(elapsed, computedDuration, repeatDelay);\\n            if (repeatType === \\\"mirror\\\")\\n                animation.flipTarget();\\n        }\\n        isComplete = false;\\n        onRepeat && onRepeat();\\n    }\\n    function complete() {\\n        driverControls.stop();\\n        onComplete && onComplete();\\n    }\\n    function update(delta) {\\n        if (!isForwardPlayback)\\n            delta = -delta;\\n        elapsed += delta;\\n        if (!isComplete) {\\n            const state = animation.next(Math.max(0, elapsed));\\n            latest = state.value;\\n            if (interpolateFromNumber)\\n                latest = interpolateFromNumber(latest);\\n            isComplete = isForwardPlayback ? state.done : elapsed <= 0;\\n        }\\n        onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(latest);\\n        if (isComplete) {\\n            if (repeatCount === 0)\\n                computedDuration !== null && computedDuration !== void 0 ? computedDuration : (computedDuration = elapsed);\\n            if (repeatCount < repeatMax) {\\n                hasRepeatDelayElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback) && repeat();\\n            }\\n            else {\\n                complete();\\n            }\\n        }\\n    }\\n    function play() {\\n        onPlay === null || onPlay === void 0 ? void 0 : onPlay();\\n        driverControls = driver(update);\\n        driverControls.start();\\n    }\\n    autoplay && play();\\n    return {\\n        stop: () => {\\n            onStop === null || onStop === void 0 ? void 0 : onStop();\\n            driverControls.stop();\\n        },\\n    };\\n}\\n\\nfunction velocityPerSecond(velocity, frameDuration) {\\n    return frameDuration ? velocity * (1000 / frameDuration) : 0;\\n}\\n\\nfunction inertia({ from = 0, velocity = 0, min, max, power = 0.8, timeConstant = 750, bounceStiffness = 500, bounceDamping = 10, restDelta = 1, modifyTarget, driver, onUpdate, onComplete, onStop, }) {\\n    let currentAnimation;\\n    function isOutOfBounds(v) {\\n        return (min !== undefined && v < min) || (max !== undefined && v > max);\\n    }\\n    function boundaryNearest(v) {\\n        if (min === undefined)\\n            return max;\\n        if (max === undefined)\\n            return min;\\n        return Math.abs(min - v) < Math.abs(max - v) ? min : max;\\n    }\\n    function startAnimation(options) {\\n        currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop();\\n        currentAnimation = animate(Object.assign(Object.assign({}, options), { driver, onUpdate: (v) => {\\n                var _a;\\n                onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(v);\\n                (_a = options.onUpdate) === null || _a === void 0 ? void 0 : _a.call(options, v);\\n            }, onComplete,\\n            onStop }));\\n    }\\n    function startSpring(options) {\\n        startAnimation(Object.assign({ type: \\\"spring\\\", stiffness: bounceStiffness, damping: bounceDamping, restDelta }, options));\\n    }\\n    if (isOutOfBounds(from)) {\\n        startSpring({ from, velocity, to: boundaryNearest(from) });\\n    }\\n    else {\\n        let target = power * velocity + from;\\n        if (typeof modifyTarget !== \\\"undefined\\\")\\n            target = modifyTarget(target);\\n        const boundary = boundaryNearest(target);\\n        const heading = boundary === min ? -1 : 1;\\n        let prev;\\n        let current;\\n        const checkBoundary = (v) => {\\n            prev = current;\\n            current = v;\\n            velocity = velocityPerSecond(v - prev, sync.getFrameData().delta);\\n            if ((heading === 1 && v > boundary) ||\\n                (heading === -1 && v < boundary)) {\\n                startSpring({ from: v, to: boundary, velocity });\\n            }\\n        };\\n        startAnimation({\\n            type: \\\"decay\\\",\\n            from,\\n            velocity,\\n            timeConstant,\\n            power,\\n            restDelta,\\n            modifyTarget,\\n            onUpdate: isOutOfBounds(target) ? checkBoundary : undefined,\\n        });\\n    }\\n    return {\\n        stop: () => currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop(),\\n    };\\n}\\n\\nconst radiansToDegrees = (radians) => (radians * 180) / Math.PI;\\n\\nconst angle = (a, b = zeroPoint) => radiansToDegrees(Math.atan2(b.y - a.y, b.x - a.x));\\n\\nconst applyOffset = (from, to) => {\\n    let hasReceivedFrom = true;\\n    if (to === undefined) {\\n        to = from;\\n        hasReceivedFrom = false;\\n    }\\n    return (v) => {\\n        if (hasReceivedFrom) {\\n            return v - from + to;\\n        }\\n        else {\\n            from = v;\\n            hasReceivedFrom = true;\\n            return to;\\n        }\\n    };\\n};\\n\\nconst identity = (v) => v;\\nconst createAttractor = (alterDisplacement = identity) => (constant, origin, v) => {\\n    const displacement = origin - v;\\n    const springModifiedDisplacement = -(0 - constant + 1) * (0 - alterDisplacement(Math.abs(displacement)));\\n    return displacement <= 0\\n        ? origin + springModifiedDisplacement\\n        : origin - springModifiedDisplacement;\\n};\\nconst attract = createAttractor();\\nconst attractExpo = createAttractor(Math.sqrt);\\n\\nconst degreesToRadians = (degrees) => (degrees * Math.PI) / 180;\\n\\nconst isPoint = (point) => point.hasOwnProperty('x') && point.hasOwnProperty('y');\\n\\nconst isPoint3D = (point) => isPoint(point) && point.hasOwnProperty('z');\\n\\nconst distance1D = (a, b) => Math.abs(a - b);\\nfunction distance(a, b) {\\n    if (isNum(a) && isNum(b)) {\\n        return distance1D(a, b);\\n    }\\n    else if (isPoint(a) && isPoint(b)) {\\n        const xDelta = distance1D(a.x, b.x);\\n        const yDelta = distance1D(a.y, b.y);\\n        const zDelta = isPoint3D(a) && isPoint3D(b) ? distance1D(a.z, b.z) : 0;\\n        return Math.sqrt(Math.pow(xDelta, 2) + Math.pow(yDelta, 2) + Math.pow(zDelta, 2));\\n    }\\n}\\n\\nconst pointFromVector = (origin, angle, distance) => {\\n    angle = degreesToRadians(angle);\\n    return {\\n        x: distance * Math.cos(angle) + origin.x,\\n        y: distance * Math.sin(angle) + origin.y\\n    };\\n};\\n\\nconst toDecimal = (num, precision = 2) => {\\n    precision = Math.pow(10, precision);\\n    return Math.round(num * precision) / precision;\\n};\\n\\nconst smoothFrame = (prevValue, nextValue, duration, smoothing = 0) => toDecimal(prevValue +\\n    (duration * (nextValue - prevValue)) / Math.max(smoothing, duration));\\n\\nconst smooth = (strength = 50) => {\\n    let previousValue = 0;\\n    let lastUpdated = 0;\\n    return (v) => {\\n        const currentFramestamp = sync.getFrameData().timestamp;\\n        const timeDelta = currentFramestamp !== lastUpdated ? currentFramestamp - lastUpdated : 0;\\n        const newValue = timeDelta\\n            ? smoothFrame(previousValue, v, timeDelta, strength)\\n            : previousValue;\\n        lastUpdated = currentFramestamp;\\n        previousValue = newValue;\\n        return newValue;\\n    };\\n};\\n\\nconst snap = (points) => {\\n    if (typeof points === 'number') {\\n        return (v) => Math.round(v / points) * points;\\n    }\\n    else {\\n        let i = 0;\\n        const numPoints = points.length;\\n        return (v) => {\\n            let lastDistance = Math.abs(points[0] - v);\\n            for (i = 1; i < numPoints; i++) {\\n                const point = points[i];\\n                const distance = Math.abs(point - v);\\n                if (distance === 0)\\n                    return point;\\n                if (distance > lastDistance)\\n                    return points[i - 1];\\n                if (i === numPoints - 1)\\n                    return point;\\n                lastDistance = distance;\\n            }\\n        };\\n    }\\n};\\n\\nfunction velocityPerFrame(xps, frameDuration) {\\n    return xps / (1000 / frameDuration);\\n}\\n\\nconst wrap = (min, max, v) => {\\n    const rangeSize = max - min;\\n    return ((((v - min) % rangeSize) + rangeSize) % rangeSize) + min;\\n};\\n\\nconst a = (a1, a2) => 1.0 - 3.0 * a2 + 3.0 * a1;\\nconst b = (a1, a2) => 3.0 * a2 - 6.0 * a1;\\nconst c = (a1) => 3.0 * a1;\\nconst calcBezier = (t, a1, a2) => ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;\\nconst getSlope = (t, a1, a2) => 3.0 * a(a1, a2) * t * t + 2.0 * b(a1, a2) * t + c(a1);\\nconst subdivisionPrecision = 0.0000001;\\nconst subdivisionMaxIterations = 10;\\nfunction binarySubdivide(aX, aA, aB, mX1, mX2) {\\n    let currentX;\\n    let currentT;\\n    let i = 0;\\n    do {\\n        currentT = aA + (aB - aA) / 2.0;\\n        currentX = calcBezier(currentT, mX1, mX2) - aX;\\n        if (currentX > 0.0) {\\n            aB = currentT;\\n        }\\n        else {\\n            aA = currentT;\\n        }\\n    } while (Math.abs(currentX) > subdivisionPrecision &&\\n        ++i < subdivisionMaxIterations);\\n    return currentT;\\n}\\nconst newtonIterations = 8;\\nconst newtonMinSlope = 0.001;\\nfunction newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\\n    for (let i = 0; i < newtonIterations; ++i) {\\n        const currentSlope = getSlope(aGuessT, mX1, mX2);\\n        if (currentSlope === 0.0) {\\n            return aGuessT;\\n        }\\n        const currentX = calcBezier(aGuessT, mX1, mX2) - aX;\\n        aGuessT -= currentX / currentSlope;\\n    }\\n    return aGuessT;\\n}\\nconst kSplineTableSize = 11;\\nconst kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\\n    if (mX1 === mY1 && mX2 === mY2)\\n        return linear;\\n    const sampleValues = new Float32Array(kSplineTableSize);\\n    for (let i = 0; i < kSplineTableSize; ++i) {\\n        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\\n    }\\n    function getTForX(aX) {\\n        let intervalStart = 0.0;\\n        let currentSample = 1;\\n        const lastSample = kSplineTableSize - 1;\\n        for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\\n            intervalStart += kSampleStepSize;\\n        }\\n        --currentSample;\\n        const dist = (aX - sampleValues[currentSample]) /\\n            (sampleValues[currentSample + 1] - sampleValues[currentSample]);\\n        const guessForT = intervalStart + dist * kSampleStepSize;\\n        const initialSlope = getSlope(guessForT, mX1, mX2);\\n        if (initialSlope >= newtonMinSlope) {\\n            return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\\n        }\\n        else if (initialSlope === 0.0) {\\n            return guessForT;\\n        }\\n        else {\\n            return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\\n        }\\n    }\\n    return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\\n}\\n\\nconst steps = (steps, direction = 'end') => (progress) => {\\n    progress =\\n        direction === 'end' ? Math.min(progress, 0.999) : Math.max(progress, 0.001);\\n    const expanded = progress * steps;\\n    const rounded = direction === 'end' ? Math.floor(expanded) : Math.ceil(expanded);\\n    return clamp(0, 1, rounded / steps);\\n};\\n\\nexports.angle = angle;\\nexports.animate = animate;\\nexports.anticipate = anticipate;\\nexports.applyOffset = applyOffset;\\nexports.attract = attract;\\nexports.attractExpo = attractExpo;\\nexports.backIn = backIn;\\nexports.backInOut = backInOut;\\nexports.backOut = backOut;\\nexports.bounceIn = bounceIn;\\nexports.bounceInOut = bounceInOut;\\nexports.bounceOut = bounceOut;\\nexports.circIn = circIn;\\nexports.circInOut = circInOut;\\nexports.circOut = circOut;\\nexports.clamp = clamp;\\nexports.createAnticipate = createAnticipate;\\nexports.createAttractor = createAttractor;\\nexports.createBackIn = createBackIn;\\nexports.createExpoIn = createExpoIn;\\nexports.cubicBezier = cubicBezier;\\nexports.decay = decay;\\nexports.degreesToRadians = degreesToRadians;\\nexports.distance = distance;\\nexports.easeIn = easeIn;\\nexports.easeInOut = easeInOut;\\nexports.easeOut = easeOut;\\nexports.inertia = inertia;\\nexports.interpolate = interpolate;\\nexports.isPoint = isPoint;\\nexports.isPoint3D = isPoint3D;\\nexports.keyframes = keyframes;\\nexports.linear = linear;\\nexports.mirrorEasing = mirrorEasing;\\nexports.mix = mix;\\nexports.mixColor = mixColor;\\nexports.mixComplex = mixComplex;\\nexports.pipe = pipe;\\nexports.pointFromVector = pointFromVector;\\nexports.progress = progress;\\nexports.radiansToDegrees = radiansToDegrees;\\nexports.reverseEasing = reverseEasing;\\nexports.smooth = smooth;\\nexports.smoothFrame = smoothFrame;\\nexports.snap = snap;\\nexports.spring = spring;\\nexports.steps = steps;\\nexports.toDecimal = toDecimal;\\nexports.velocityPerFrame = velocityPerFrame;\\nexports.velocityPerSecond = velocityPerSecond;\\nexports.wrap = wrap;\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"findSpring\",\"duration\",\"bounce\",\"velocity\",\"mass\",\"envelope\",\"heyListen\",\"warning\",\"dampingRatio\",\"clamp\",\"minDamping\",\"maxDamping\",\"minDuration\",\"maxDuration\",\"undampedFreq\",\"exponentialDecay\",\"safeMin\",\"Math\",\"sqrt\",\"exp\",\"c\",\"derivative\",\"delta\",\"d\",\"e\",\"pow\",\"f\",\"g\",\"factor\",\"a\",\"approximateRoot\",\"isNaN\",\"stiffness\",\"damping\",\"initialGuess\",\"i\",\"rootIterations\",\"result\",\"isSpringType\",\"options\",\"keys\",\"some\",\"key\",\"undefined\",\"getSpringOptions\",\"springOptions\",\"Object\",\"assign\",\"isResolvedFromDuration\",\"physicsKeys\",\"durationKeys\",\"derived\",\"spring\",\"_a\",\"createSpring\",\"initialVelocity\",\"initialDelta\",\"to\",\"from\",\"undampedAngularFreq\",\"restDelta\",\"min\",\"abs\",\"angularFreq\",\"resolveSpring\",\"t\",\"sin\",\"cos\",\"resolveVelocity\",\"dampedAngularFreq\",\"freqForT\",\"sinh\",\"cosh\",\"restSpeed\",\"tslib\",\"__rest\",\"state\",\"done\",\"value\",\"zero\",\"next\",\"current\",\"currentVelocity\",\"isBelowDisplacementThreshold\",\"flipTarget\",\"hueToRgb\",\"p\",\"q\",\"hslaToRgba\",\"hue\",\"saturation\",\"lightness\",\"alpha\",\"red\",\"green\",\"blue\",\"round\",\"getMixer\",\"origin\",\"target\",\"v\",\"styleValueTypes\",\"color\",\"test\",\"mixColor\",\"mixComplex\",\"analyse\",\"parsed\",\"complex\",\"parse\",\"numValues\",\"length\",\"numNumbers\",\"numRGB\",\"numHSL\",\"detectMixerFactory\",\"mixNumber\",\"Array\",\"isArray\",\"mixArray\",\"mixObject\",\"createMixers\",\"output\",\"ease\",\"customMixer\",\"mixers\",\"mixerFactory\",\"numMixers\",\"mixer\",\"easingFunction\",\"reduce\",\"combineFunctions\",\"push\",\"fastInterpolate\",\"progress\",\"slowInterpolate\",\"input\",\"inputLength\",\"lastInputIndex\",\"mixerIndex\",\"foundMixerIndex\",\"progressInRange\",\"interpolate\",\"isClamp\",\"invariant\",\"concat\",\"reverse\",\"interpolator\",\"defaultEasing\",\"values\",\"easing\",\"map\",\"easeInOut\",\"splice\",\"defaultOffset\",\"_value\",\"convertOffsetToTimes\",\"offset\",\"o\",\"keyframes\",\"createInterpolator\",\"times\",\"decay\",\"power\",\"timeConstant\",\"modifyTarget\",\"amplitude\",\"ideal\",\"detectAnimationFromOptions\",\"config\",\"types\",\"type\",\"Set\",\"has\",\"loopElapsed\",\"elapsed\",\"delay\",\"reverseElapsed\",\"isForwardPlayback\",\"animate\",\"update\",\"isComplete\",\"animation\",\"max\",\"latest\",\"interpolateFromNumber\",\"onUpdate\",\"repeatCount\",\"computedDuration\",\"repeatMax\",\"repeatDelay\",\"repeatType\",\"onRepeat\",\"driverControls\",\"stop\",\"onComplete\",\"_c\",\"autoplay\",\"driver\",\"framesync\",\"onPlay\",\"onStop\",\"animator\",\"needsInterpolation\",\"call\",\"start\",\"velocityPerSecond\",\"frameDuration\",\"defineProperty\",\"sync\",\"sync__default\",\"b\",\"spring.needsInterpolation\",\"_t\",\"toFromDifference\",\"colorTypes\",\"hex\",\"rgba\",\"hsla\",\"getColorType\",\"find\",\"notAnimatable\",\"fromColorType\",\"toColorType\",\"fromColor\",\"toColor\",\"blended\",\"fromExpo\",\"transform\",\"zeroPoint\",\"x\",\"y\",\"z\",\"blendValue\",\"fromThis\",\"template\",\"createTransformer\",\"originStats\",\"targetStats\",\"transformers\",\"reverseEasing\",\"mirrorEasing\",\"createExpoIn\",\"createBackIn\",\"createAnticipate\",\"backEasing\",\"BOUNCE_FIRST_THRESHOLD\",\"BOUNCE_SECOND_THRESHOLD\",\"linear\",\"easeIn\",\"easeOut\",\"circIn\",\"acos\",\"circOut\",\"circInOut\",\"backIn\",\"DEFAULT_OVERSHOOT_STRENGTH\",\"backOut\",\"backInOut\",\"anticipate\",\"ca\",\"cb\",\"cc\",\"bounceOut\",\"p2\",\"BOUNCE_THIRD_THRESHOLD\",\"bounceIn\",\"passTimestamp\",\"cancelSync\",\"identity\",\"createAttractor\",\"alterDisplacement\",\"constant\",\"displacement\",\"springModifiedDisplacement\",\"attract\",\"attractExpo\",\"isPoint\",\"point\",\"hasOwnProperty\",\"isPoint3D\",\"toDecimal\",\"num\",\"precision\",\"smoothFrame\",\"prevValue\",\"nextValue\",\"smoothing\",\"calcBezier\",\"a1\",\"a2\",\"angle\",\"atan2\",\"radians\",\"PI\",\"applyOffset\",\"hasReceivedFrom\",\"bounceInOut\",\"cubicBezier\",\"mX1\",\"mY1\",\"mX2\",\"mY2\",\"sampleValues\",\"Float32Array\",\"kSplineTableSize\",\"kSampleStepSize\",\"intervalStart\",\"currentSample\",\"lastSample\",\"aX\",\"guessForT\",\"initialSlope\",\"newtonMinSlope\",\"newtonIterations\",\"currentSlope\",\"aGuessT\",\"currentX\",\"currentT\",\"aA\",\"aB\",\"subdivisionPrecision\",\"subdivisionMaxIterations\",\"degreesToRadians\",\"degrees\",\"distance\",\"xDelta\",\"yDelta\",\"zDelta\",\"inertia\",\"bounceStiffness\",\"bounceDamping\",\"boundaryNearest\",\"startAnimation\",\"currentAnimation\",\"startSpring\",\"boundary\",\"heading\",\"prev\",\"checkBoundary\",\"getFrameData\",\"mix\",\"pipe\",\"pointFromVector\",\"radiansToDegrees\",\"smooth\",\"strength\",\"previousValue\",\"lastUpdated\",\"currentFramestamp\",\"timestamp\",\"timeDelta\",\"newValue\",\"snap\",\"points\",\"numPoints\",\"lastDistance\",\"steps\",\"direction\",\"expanded\",\"rounded\",\"floor\",\"ceil\",\"velocityPerFrame\",\"xps\",\"wrap\",\"rangeSize\"]\n}\n"]