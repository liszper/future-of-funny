'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (config) {
  var MAX = config.MAX;
  var every = config.every;
  var on = config.on;
  var datepart = config.datepart;
  var resolution = config.resolution;


  return function (_ref) {
    var layers = _ref.layers;
    return function (props) {

      function isDefault(res) {
        return layers[res].interval <= 1 && layers[res].type == _recurrence2.default.Every;
      }

      function isLowerResolutionAndNotDefault(res) {
        return resolution > layers[res].resolution && (!isDefault(res) || layers[res].interval == null);
      }

      function isHigherResolutionAndNotDefault(res) {
        return resolution < layers[res].resolution && (!isDefault(res) || layers[res].interval == null);
      }

      var next = props.next;
      var initialRun = props.initialRun;
      var forceAdvance = props.forceAdvance;
      var date = props.date;
      var _layers$resolution = layers[resolution];
      var type = _layers$resolution.type;
      var interval = _layers$resolution.interval;

      //console.log(`Entering ${resolution} with ${date}`)

      // if interval is null that means this layer is disabled

      if (interval === null && isDefault(resolution) && next) return next({
        date: date,
        initialRun: initialRun
      });

      //Iterate through layers and observer whether
      //any of the higher layers are non-default and therefore
      //whether it makes sense to visit them first
      var isHigherResNonDefault = Object.keys(layers).reduce(function (c, e) {
        return c || isHigherResolutionAndNotDefault(e);
      }, false);

      //Iterate through layers and determine whether
      //is higher layer disabled
      var isHigherLayerDisabled = false;
      Object.keys(layers).forEach(function (e) {
        if (layers[e].resolution > resolution) {
          if (layers[e].interval == null) isHigherLayerDisabled = true;
          return false;
        }
        return true;
      });

      var maxValue = isFunction(MAX) ? MAX({
        date: date,
        isHigherResNonDefault: isHigherResNonDefault,
        layers: layers
      }) : MAX;

      if (type == _recurrence2.default.Every) {

        //Get the next date part and add wanted interval
        var part = datepart({
          date: date,
          isHigherResNonDefault: isHigherResNonDefault,
          isHigherLayerDisabled: isHigherLayerDisabled
        }) + interval;

        if ((initialRun || isHigherResNonDefault && part > maxValue) && next) date = next({
          date: date,
          initialRun: initialRun
        });else if (!initialRun || forceAdvance) {
          date = every({
            date: date,
            interval: interval
          });
        }
      } else if (type == _recurrence2.default.On) {

        var _part = datepart({
          date: date,
          isHigherResNonDefault: isHigherResNonDefault,
          isHigherLayerDisabled: isHigherLayerDisabled
        });

        //for initial run we're gonna go through all resolutions
        //to setup the start date
        if (initialRun && next) date = next({
          date: date,
          initialRun: initialRun
        });

        //if the wanted recurrence is not possible to setup
        //because the date date would be smaller than
        //the actual date we move on to next resolution
        else if (_part >= interval && next) date = next({
            date: date,
            initialRun: initialRun,
            forceAdvance: true
          });

        //setting up the defined date part
        date = on({
          date: date,
          interval: interval,
          isHigherLayerDisabled: isHigherLayerDisabled
        });
      }

      // Clears the closest lower resolution in the date time
      Object.keys(layers).forEach(function (e) {
        return !initialRun && isLowerResolutionAndNotDefault(layers[e].resolution) ? clear(date, layers[e].resolution) : true;
      });

      //console.log(`Leaving ${resolution} with ${date}`)

      return date;
    };
  };
};

var _recurrence = require('../recurrence');

var _recurrence2 = _interopRequireDefault(_recurrence);

var _resolution = require('../resolution');

var _resolution2 = _interopRequireDefault(_resolution);

var _utils = require('../utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isFunction(functionToCheck) {
  var getType = {};
  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
}

function clear(date, res) {
  switch (res) {
    case _resolution2.default.Week:
      date.setDate(1);
      return;
    case _resolution2.default.Day:
      {
        var weeks = (0, _utils.getIsoWeekFromDate)(date);
        date = (0, _utils.getDateOfISOWeek)(weeks, date.getFullYear());
        return;
      }
    case _resolution2.default.Hour:
      date.setHours(0);
      return;
    case _resolution2.default.Minute:
      date.setMinutes(0);
      return;
    case _resolution2.default.Second:
      date.setSeconds(0);
      return;
    case _resolution2.default.Millisecond:
      date.setMilliseconds(0);
      return;
  }
}

/**
 * Implements the common flow for all resolutions
 * @param  {Object} config   Configuration object defining timeframe on which
 *                           this specific resolution works
 * @return {Function}        Resolution function performing operation for
 *                           a certain date part based on the config object
 */