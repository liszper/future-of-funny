["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react-remove-scroll/dist/es5/handleScroll.js"],"~:js","shadow$provide.module$node_modules$react_remove_scroll$dist$es5$handleScroll=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.handleScroll=exports.locationCouldBeScrolled=void 0;var elementCanBeScrolled=function(node,overflow){var styles=window.getComputedStyle(node);return\"hidden\"!==styles[overflow]&&!(styles.overflowY===styles.overflowX&&\"TEXTAREA\"!==node.tagName&&\"visible\"===styles[overflow])};exports.locationCouldBeScrolled=function(axis,node){do{\"undefined\"!==\ntypeof ShadowRoot&&node instanceof ShadowRoot&&(node=node.host);if(elementCouldBeScrolled(axis,node)){var _a=getScrollVariables(axis,node);if(_a[1]>_a[2])return!0}node=node.parentNode}while(node&&node!==document.body);return!1};var elementCouldBeScrolled=function(axis,node){return\"v\"===axis?elementCanBeScrolled(node,\"overflowY\"):elementCanBeScrolled(node,\"overflowX\")},getScrollVariables=function(axis,node){return\"v\"===axis?[node.scrollTop,node.scrollHeight,node.clientHeight]:[node.scrollLeft,node.scrollWidth,\nnode.clientWidth]};exports.handleScroll=function(axis,endTarget,event,sourceDelta,noOverscroll){var directionFactor=window.getComputedStyle(endTarget).direction;directionFactor=\"h\"===axis&&\"rtl\"===directionFactor?-1:1;sourceDelta*=directionFactor;event=event.target;var targetInLock=endTarget.contains(event),shouldCancelScroll=!1,isDeltaPositive=0<sourceDelta,availableScroll=0,availableScrollTop=0;do{var _a=getScrollVariables(axis,event),position=_a[0];_a=_a[1]-_a[2]-directionFactor*position;(position||\n_a)&&elementCouldBeScrolled(axis,event)&&(availableScroll+=_a,availableScrollTop+=position);event=event.parentNode}while(!targetInLock&&event!==document.body||targetInLock&&(endTarget.contains(event)||endTarget===event));isDeltaPositive&&(noOverscroll&&0===availableScroll||!noOverscroll&&sourceDelta>availableScroll)?shouldCancelScroll=!0:!isDeltaPositive&&(noOverscroll&&0===availableScrollTop||!noOverscroll&&-sourceDelta>availableScrollTop)&&(shouldCancelScroll=!0);return shouldCancelScroll}}","~:source","shadow$provide[\"module$node_modules$react_remove_scroll$dist$es5$handleScroll\"] = function(global,require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.handleScroll = exports.locationCouldBeScrolled = void 0;\nvar alwaysContainsScroll = function (node) {\n    // textarea will always _contain_ scroll inside self. It only can be hidden\n    return node.tagName === 'TEXTAREA';\n};\nvar elementCanBeScrolled = function (node, overflow) {\n    var styles = window.getComputedStyle(node);\n    return (\n    // not-not-scrollable\n    styles[overflow] !== 'hidden' &&\n        // contains scroll inside self\n        !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === 'visible'));\n};\nvar elementCouldBeVScrolled = function (node) { return elementCanBeScrolled(node, 'overflowY'); };\nvar elementCouldBeHScrolled = function (node) { return elementCanBeScrolled(node, 'overflowX'); };\nvar locationCouldBeScrolled = function (axis, node) {\n    var current = node;\n    do {\n        // Skip over shadow root\n        if (typeof ShadowRoot !== 'undefined' && current instanceof ShadowRoot) {\n            current = current.host;\n        }\n        var isScrollable = elementCouldBeScrolled(axis, current);\n        if (isScrollable) {\n            var _a = getScrollVariables(axis, current), s = _a[1], d = _a[2];\n            if (s > d) {\n                return true;\n            }\n        }\n        current = current.parentNode;\n    } while (current && current !== document.body);\n    return false;\n};\nexports.locationCouldBeScrolled = locationCouldBeScrolled;\nvar getVScrollVariables = function (_a) {\n    var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;\n    return [\n        scrollTop,\n        scrollHeight,\n        clientHeight,\n    ];\n};\nvar getHScrollVariables = function (_a) {\n    var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;\n    return [\n        scrollLeft,\n        scrollWidth,\n        clientWidth,\n    ];\n};\nvar elementCouldBeScrolled = function (axis, node) {\n    return axis === 'v' ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);\n};\nvar getScrollVariables = function (axis, node) {\n    return axis === 'v' ? getVScrollVariables(node) : getHScrollVariables(node);\n};\nvar getDirectionFactor = function (axis, direction) {\n    /**\n     * If the element's direction is rtl (right-to-left), then scrollLeft is 0 when the scrollbar is at its rightmost position,\n     * and then increasingly negative as you scroll towards the end of the content.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollLeft\n     */\n    return axis === 'h' && direction === 'rtl' ? -1 : 1;\n};\nvar handleScroll = function (axis, endTarget, event, sourceDelta, noOverscroll) {\n    var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);\n    var delta = directionFactor * sourceDelta;\n    // find scrollable target\n    var target = event.target;\n    var targetInLock = endTarget.contains(target);\n    var shouldCancelScroll = false;\n    var isDeltaPositive = delta > 0;\n    var availableScroll = 0;\n    var availableScrollTop = 0;\n    do {\n        var _a = getScrollVariables(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2];\n        var elementScroll = scroll_1 - capacity - directionFactor * position;\n        if (position || elementScroll) {\n            if (elementCouldBeScrolled(axis, target)) {\n                availableScroll += elementScroll;\n                availableScrollTop += position;\n            }\n        }\n        target = target.parentNode;\n    } while (\n    // portaled content\n    (!targetInLock && target !== document.body) ||\n        // self content\n        (targetInLock && (endTarget.contains(target) || endTarget === target)));\n    if (isDeltaPositive && ((noOverscroll && availableScroll === 0) || (!noOverscroll && delta > availableScroll))) {\n        shouldCancelScroll = true;\n    }\n    else if (!isDeltaPositive &&\n        ((noOverscroll && availableScrollTop === 0) || (!noOverscroll && -delta > availableScrollTop))) {\n        shouldCancelScroll = true;\n    }\n    return shouldCancelScroll;\n};\nexports.handleScroll = handleScroll;\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["__esModule","value","locationCouldBeScrolled","handleScroll"]],"~:compiled-at",1681642524896,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react_remove_scroll$dist$es5$handleScroll.js\",\n\"lineCount\":4,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/react-remove-scroll/dist/es5/handleScroll.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$react_remove_scroll$dist$es5$handleScroll\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nexports.handleScroll = exports.locationCouldBeScrolled = void 0;\\nvar alwaysContainsScroll = function (node) {\\n    // textarea will always _contain_ scroll inside self. It only can be hidden\\n    return node.tagName === 'TEXTAREA';\\n};\\nvar elementCanBeScrolled = function (node, overflow) {\\n    var styles = window.getComputedStyle(node);\\n    return (\\n    // not-not-scrollable\\n    styles[overflow] !== 'hidden' &&\\n        // contains scroll inside self\\n        !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === 'visible'));\\n};\\nvar elementCouldBeVScrolled = function (node) { return elementCanBeScrolled(node, 'overflowY'); };\\nvar elementCouldBeHScrolled = function (node) { return elementCanBeScrolled(node, 'overflowX'); };\\nvar locationCouldBeScrolled = function (axis, node) {\\n    var current = node;\\n    do {\\n        // Skip over shadow root\\n        if (typeof ShadowRoot !== 'undefined' && current instanceof ShadowRoot) {\\n            current = current.host;\\n        }\\n        var isScrollable = elementCouldBeScrolled(axis, current);\\n        if (isScrollable) {\\n            var _a = getScrollVariables(axis, current), s = _a[1], d = _a[2];\\n            if (s > d) {\\n                return true;\\n            }\\n        }\\n        current = current.parentNode;\\n    } while (current && current !== document.body);\\n    return false;\\n};\\nexports.locationCouldBeScrolled = locationCouldBeScrolled;\\nvar getVScrollVariables = function (_a) {\\n    var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;\\n    return [\\n        scrollTop,\\n        scrollHeight,\\n        clientHeight,\\n    ];\\n};\\nvar getHScrollVariables = function (_a) {\\n    var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;\\n    return [\\n        scrollLeft,\\n        scrollWidth,\\n        clientWidth,\\n    ];\\n};\\nvar elementCouldBeScrolled = function (axis, node) {\\n    return axis === 'v' ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);\\n};\\nvar getScrollVariables = function (axis, node) {\\n    return axis === 'v' ? getVScrollVariables(node) : getHScrollVariables(node);\\n};\\nvar getDirectionFactor = function (axis, direction) {\\n    /**\\n     * If the element's direction is rtl (right-to-left), then scrollLeft is 0 when the scrollbar is at its rightmost position,\\n     * and then increasingly negative as you scroll towards the end of the content.\\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollLeft\\n     */\\n    return axis === 'h' && direction === 'rtl' ? -1 : 1;\\n};\\nvar handleScroll = function (axis, endTarget, event, sourceDelta, noOverscroll) {\\n    var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);\\n    var delta = directionFactor * sourceDelta;\\n    // find scrollable target\\n    var target = event.target;\\n    var targetInLock = endTarget.contains(target);\\n    var shouldCancelScroll = false;\\n    var isDeltaPositive = delta > 0;\\n    var availableScroll = 0;\\n    var availableScrollTop = 0;\\n    do {\\n        var _a = getScrollVariables(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2];\\n        var elementScroll = scroll_1 - capacity - directionFactor * position;\\n        if (position || elementScroll) {\\n            if (elementCouldBeScrolled(axis, target)) {\\n                availableScroll += elementScroll;\\n                availableScrollTop += position;\\n            }\\n        }\\n        target = target.parentNode;\\n    } while (\\n    // portaled content\\n    (!targetInLock && target !== document.body) ||\\n        // self content\\n        (targetInLock && (endTarget.contains(target) || endTarget === target)));\\n    if (isDeltaPositive && ((noOverscroll && availableScroll === 0) || (!noOverscroll && delta > availableScroll))) {\\n        shouldCancelScroll = true;\\n    }\\n    else if (!isDeltaPositive &&\\n        ((noOverscroll && availableScrollTop === 0) || (!noOverscroll && -delta > availableScrollTop))) {\\n        shouldCancelScroll = true;\\n    }\\n    return shouldCancelScroll;\\n};\\nexports.handleScroll = handleScroll;\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"handleScroll\",\"locationCouldBeScrolled\",\"elementCanBeScrolled\",\"node\",\"overflow\",\"styles\",\"window\",\"getComputedStyle\",\"overflowY\",\"overflowX\",\"tagName\",\"axis\",\"ShadowRoot\",\"current\",\"host\",\"elementCouldBeScrolled\",\"isScrollable\",\"_a\",\"getScrollVariables\",\"s\",\"d\",\"parentNode\",\"document\",\"body\",\"scrollTop\",\"scrollHeight\",\"clientHeight\",\"scrollLeft\",\"scrollWidth\",\"clientWidth\",\"endTarget\",\"event\",\"sourceDelta\",\"noOverscroll\",\"direction\",\"delta\",\"directionFactor\",\"target\",\"targetInLock\",\"contains\",\"shouldCancelScroll\",\"isDeltaPositive\",\"availableScroll\",\"availableScrollTop\",\"position\",\"elementScroll\",\"scroll_1\",\"capacity\"]\n}\n"]