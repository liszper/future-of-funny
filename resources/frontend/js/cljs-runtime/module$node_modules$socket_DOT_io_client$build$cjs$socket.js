shadow$provide.module$node_modules$socket_DOT_io_client$build$cjs$socket=function(global,require,module,exports){global=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{"default":mod}};Object.defineProperty(exports,"__esModule",{value:!0});exports.Socket=void 0;const socket_io_parser_1=require("module$node_modules$socket_DOT_io_parser$build$cjs$index"),on_js_1=require("module$node_modules$socket_DOT_io_client$build$cjs$on");module=require("module$node_modules$$socket_DOT_io$component_emitter$index");
const debug=global(require("module$node_modules$socket_DOT_io_client$node_modules$debug$src$browser")).default("socket.io-client:socket"),RESERVED_EVENTS=Object.freeze({connect:1,connect_error:1,disconnect:1,disconnecting:1,newListener:1,removeListener:1});class Socket extends module.Emitter{constructor(io,nsp,opts){super();this.connected=!1;this.receiveBuffer=[];this.sendBuffer=[];this.ids=0;this.acks={};this.flags={};this.io=io;this.nsp=nsp;opts&&opts.auth&&(this.auth=opts.auth);this.io._autoConnect&&
this.open()}get disconnected(){return!this.connected}subEvents(){if(!this.subs){var io=this.io;this.subs=[on_js_1.on(io,"open",this.onopen.bind(this)),on_js_1.on(io,"packet",this.onpacket.bind(this)),on_js_1.on(io,"error",this.onerror.bind(this)),on_js_1.on(io,"close",this.onclose.bind(this))]}}get active(){return!!this.subs}connect(){if(this.connected)return this;this.subEvents();this.io._reconnecting||this.io.open();if("open"===this.io._readyState)this.onopen();return this}open(){return this.connect()}send(...args){args.unshift("message");
this.emit.apply(this,args);return this}emit(ev,...args){if(RESERVED_EVENTS.hasOwnProperty(ev))throw Error('"'+ev.toString()+'" is a reserved event name');args.unshift(ev);ev={type:socket_io_parser_1.PacketType.EVENT,data:args,options:{}};ev.options.compress=!1!==this.flags.compress;if("function"===typeof args[args.length-1]){const id=this.ids++;debug("emitting packet with ack id %d",id);args=args.pop();this._registerAckCallback(id,args);ev.id=id}args=this.io.engine&&this.io.engine.transport&&this.io.engine.transport.writable;
!this.flags.volatile||args&&this.connected?this.connected?(this.notifyOutgoingListeners(ev),this.packet(ev)):this.sendBuffer.push(ev):debug("discard packet as the transport is not currently writable");this.flags={};return this}_registerAckCallback(id,ack){const timeout=this.flags.timeout;if(void 0===timeout)this.acks[id]=ack;else{var timer=this.io.setTimeoutFn(()=>{delete this.acks[id];for(let i=0;i<this.sendBuffer.length;i++)this.sendBuffer[i].id===id&&(debug("removing packet with ack id %d from the buffer",
id),this.sendBuffer.splice(i,1));debug("event with ack id %d has timed out after %d ms",id,timeout);ack.call(this,Error("operation has timed out"))},timeout);this.acks[id]=(...args)=>{this.io.clearTimeoutFn(timer);ack.apply(this,[null,...args])}}}packet(packet){packet.nsp=this.nsp;this.io._packet(packet)}onopen(){debug("transport is open - connecting");"function"==typeof this.auth?this.auth(data=>{this.packet({type:socket_io_parser_1.PacketType.CONNECT,data})}):this.packet({type:socket_io_parser_1.PacketType.CONNECT,
data:this.auth})}onerror(err){this.connected||this.emitReserved("connect_error",err)}onclose(reason,description){debug("close (%s)",reason);this.connected=!1;delete this.id;this.emitReserved("disconnect",reason,description)}onpacket(packet){if(packet.nsp===this.nsp)switch(packet.type){case socket_io_parser_1.PacketType.CONNECT:if(packet.data&&packet.data.sid)this.onconnect(packet.data.sid);else this.emitReserved("connect_error",Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
break;case socket_io_parser_1.PacketType.EVENT:case socket_io_parser_1.PacketType.BINARY_EVENT:this.onevent(packet);break;case socket_io_parser_1.PacketType.ACK:case socket_io_parser_1.PacketType.BINARY_ACK:this.onack(packet);break;case socket_io_parser_1.PacketType.DISCONNECT:this.ondisconnect();break;case socket_io_parser_1.PacketType.CONNECT_ERROR:this.destroy();const err=Error(packet.data.message);err.data=packet.data.data;this.emitReserved("connect_error",err)}}onevent(packet){const args=packet.data||
[];debug("emitting event %j",args);null!=packet.id&&(debug("attaching ack callback to event"),args.push(this.ack(packet.id)));this.connected?this.emitEvent(args):this.receiveBuffer.push(Object.freeze(args))}emitEvent(args){if(this._anyListeners&&this._anyListeners.length){const listeners=this._anyListeners.slice();for(const listener of listeners)listener.apply(this,args)}super.emit.apply(this,args)}ack(id){const self=this;let sent=!1;return function(...args){sent||(sent=!0,debug("sending ack %j",
args),self.packet({type:socket_io_parser_1.PacketType.ACK,id,data:args}))}}onack(packet){const ack=this.acks[packet.id];"function"===typeof ack?(debug("calling ack %s with %j",packet.id,packet.data),ack.apply(this,packet.data),delete this.acks[packet.id]):debug("bad ack %s",packet.id)}onconnect(id){debug("socket connected with id %s",id);this.id=id;this.connected=!0;this.emitBuffered();this.emitReserved("connect")}emitBuffered(){this.receiveBuffer.forEach(args=>this.emitEvent(args));this.receiveBuffer=
[];this.sendBuffer.forEach(packet=>{this.notifyOutgoingListeners(packet);this.packet(packet)});this.sendBuffer=[]}ondisconnect(){debug("server disconnect (%s)",this.nsp);this.destroy();this.onclose("io server disconnect")}destroy(){this.subs&&(this.subs.forEach(subDestroy=>subDestroy()),this.subs=void 0);this.io._destroy(this)}disconnect(){this.connected&&(debug("performing disconnect (%s)",this.nsp),this.packet({type:socket_io_parser_1.PacketType.DISCONNECT}));this.destroy();if(this.connected)this.onclose("io client disconnect");
return this}close(){return this.disconnect()}compress(compress){this.flags.compress=compress;return this}get volatile(){this.flags.volatile=!0;return this}timeout(timeout){this.flags.timeout=timeout;return this}onAny(listener){this._anyListeners=this._anyListeners||[];this._anyListeners.push(listener);return this}prependAny(listener){this._anyListeners=this._anyListeners||[];this._anyListeners.unshift(listener);return this}offAny(listener){if(!this._anyListeners)return this;if(listener){const listeners=
this._anyListeners;for(let i=0;i<listeners.length;i++)if(listener===listeners[i]){listeners.splice(i,1);break}}else this._anyListeners=[];return this}listenersAny(){return this._anyListeners||[]}onAnyOutgoing(listener){this._anyOutgoingListeners=this._anyOutgoingListeners||[];this._anyOutgoingListeners.push(listener);return this}prependAnyOutgoing(listener){this._anyOutgoingListeners=this._anyOutgoingListeners||[];this._anyOutgoingListeners.unshift(listener);return this}offAnyOutgoing(listener){if(!this._anyOutgoingListeners)return this;
if(listener){const listeners=this._anyOutgoingListeners;for(let i=0;i<listeners.length;i++)if(listener===listeners[i]){listeners.splice(i,1);break}}else this._anyOutgoingListeners=[];return this}listenersAnyOutgoing(){return this._anyOutgoingListeners||[]}notifyOutgoingListeners(packet){if(this._anyOutgoingListeners&&this._anyOutgoingListeners.length){const listeners=this._anyOutgoingListeners.slice();for(const listener of listeners)listener.apply(this,packet.data)}}}exports.Socket=Socket}
//# sourceMappingURL=module$node_modules$socket_DOT_io_client$build$cjs$socket.js.map
