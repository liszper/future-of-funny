["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@motionone/dom/dist/timeline/index.cjs.js"],"~:js","shadow$provide.module$node_modules$$motionone$dom$dist$timeline$index_cjs=function(global,require,module,exports){function createAnimationsFromTimeline(definition,_a={}){var {defaultOptions={}}=_a,timelineOptions=tslib.__rest(_a,[\"defaultOptions\"]);const animationDefinitions=[];_a=new Map;const elementCache={},timeLabels=new Map;var prevTime=0;let currentTime=0,totalDuration=0;for(let i=0;i<definition.length;i++){var segment=definition[i];if(utils.isString(segment)){timeLabels.set(segment,currentTime);\ncontinue}else if(!Array.isArray(segment)){timeLabels.set(segment.name,calcTime.calcNextTime(currentTime,segment.at,prevTime,timeLabels));continue}const [elementDefinition,keyframes$1,options$1={}]=segment;void 0!==options$1.at&&(currentTime=calcTime.calcNextTime(currentTime,options$1.at,prevTime,timeLabels));segment=0;prevTime=resolveElements.resolveElements(elementDefinition,elementCache);const numElements=prevTime.length;for(let elementIndex=0;elementIndex<numElements;elementIndex++){const elementSequence=\ngetElementSequence(prevTime[elementIndex],_a);for(const key in keyframes$1){const valueSequence=getValueSequence(key,elementSequence);let valueKeyframes=keyframes$jscomp$0.keyframesList(keyframes$1[key]);var valueOptions=options$jscomp$0.getOptions(options$1,key);let {duration=defaultOptions.duration||utils.defaults.duration,easing=defaultOptions.easing||utils.defaults.easing}=valueOptions;if(utils.isEasingGenerator(easing)){var valueIsTransform=transforms.isTransform(key);heyListen.invariant(2===\nvalueKeyframes.length||!valueIsTransform,\"spring must be provided 2 keyframes within timeline\");valueIsTransform=easing.createAnimation(valueKeyframes,()=>\"0\",valueIsTransform);easing=valueIsTransform.easing;void 0!==valueIsTransform.keyframes&&(valueKeyframes=valueIsTransform.keyframes);void 0!==valueIsTransform.duration&&(duration=valueIsTransform.duration)}valueIsTransform=stagger.resolveOption(options$1.delay,elementIndex,numElements)||0;const startTime=currentTime+valueIsTransform,targetTime=\nstartTime+duration;({offset:valueOptions=utils.defaultOffset(valueKeyframes.length)}=valueOptions);1===valueOptions.length&&0===valueOptions[0]&&(valueOptions[1]=1);const remainder=length-valueKeyframes.length;0<remainder&&utils.fillOffset(valueOptions,remainder);1===valueKeyframes.length&&valueKeyframes.unshift(null);edit.addKeyframes(valueSequence,valueKeyframes,easing,valueOptions,startTime,targetTime);segment=Math.max(valueIsTransform+duration,segment);totalDuration=Math.max(targetTime,totalDuration)}}prevTime=\ncurrentTime;currentTime+=segment}_a.forEach((valueSequences,element)=>{for(const key in valueSequences){const valueSequence=valueSequences[key];valueSequence.sort(sort.compareByTime);const keyframes=[],valueOffset=[],valueEasing=[];for(let i=0;i<valueSequence.length;i++){const {at,value,easing}=valueSequence[i];keyframes.push(value);valueOffset.push(utils.progress(0,totalDuration,at));valueEasing.push(easing||utils.defaults.easing)}0!==valueOffset[0]&&(valueOffset.unshift(0),keyframes.unshift(keyframes[0]),\nvalueEasing.unshift(\"linear\"));1!==valueOffset[valueOffset.length-1]&&(valueOffset.push(1),keyframes.push(null));animationDefinitions.push([element,key,keyframes,Object.assign(Object.assign(Object.assign({},defaultOptions),{duration:totalDuration,easing:valueEasing,offset:valueOffset}),timelineOptions)])}});return animationDefinitions}function getElementSequence(element,sequences){!sequences.has(element)&&sequences.set(element,{});return sequences.get(element)}function getValueSequence(name,sequences){sequences[name]||\n(sequences[name]=[]);return sequences[name]}Object.defineProperty(exports,\"__esModule\",{value:!0});var tslib=require(\"module$node_modules$tslib$tslib\"),heyListen=require(\"module$node_modules$hey_listen$dist$index\"),utils=require(\"module$node_modules$$motionone$utils$dist$index_cjs\"),stagger=require(\"module$node_modules$$motionone$dom$dist$utils$stagger_cjs\"),animateStyle=require(\"module$node_modules$$motionone$dom$dist$animate$animate_style_cjs\"),controls=require(\"module$node_modules$$motionone$dom$dist$animate$utils$controls_cjs\"),\nkeyframes$jscomp$0=require(\"module$node_modules$$motionone$dom$dist$animate$utils$keyframes_cjs\"),options$jscomp$0=require(\"module$node_modules$$motionone$dom$dist$animate$utils$options_cjs\"),resolveElements=require(\"module$node_modules$$motionone$dom$dist$utils$resolve_elements_cjs\"),transforms=require(\"module$node_modules$$motionone$dom$dist$animate$utils$transforms_cjs\"),calcTime=require(\"module$node_modules$$motionone$dom$dist$timeline$utils$calc_time_cjs\"),edit=require(\"module$node_modules$$motionone$dom$dist$timeline$utils$edit_cjs\"),\nsort=require(\"module$node_modules$$motionone$dom$dist$timeline$utils$sort_cjs\");exports.createAnimationsFromTimeline=createAnimationsFromTimeline;exports.timeline=function(definition$jscomp$0,options={}){var _a;definition$jscomp$0=createAnimationsFromTimeline(definition$jscomp$0,options);const animationFactories=definition$jscomp$0.map(definition=>animateStyle.animateStyle(...definition)).filter(Boolean);return controls.withControls(animationFactories,options,null===(_a=definition$jscomp$0[0])||void 0===\n_a?void 0:_a[3].duration)}}","~:source","shadow$provide[\"module$node_modules$$motionone$dom$dist$timeline$index_cjs\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar tslib = require('tslib');\nvar heyListen = require('hey-listen');\nvar utils = require('@motionone/utils');\nvar stagger = require('../utils/stagger.cjs.js');\nvar animateStyle = require('../animate/animate-style.cjs.js');\nvar controls = require('../animate/utils/controls.cjs.js');\nvar keyframes = require('../animate/utils/keyframes.cjs.js');\nvar options = require('../animate/utils/options.cjs.js');\nvar resolveElements = require('../utils/resolve-elements.cjs.js');\nvar transforms = require('../animate/utils/transforms.cjs.js');\nvar calcTime = require('./utils/calc-time.cjs.js');\nvar edit = require('./utils/edit.cjs.js');\nvar sort = require('./utils/sort.cjs.js');\n\nfunction timeline(definition, options = {}) {\n    var _a;\n    const animationDefinitions = createAnimationsFromTimeline(definition, options);\n    /**\n     * Create and start animations\n     */\n    const animationFactories = animationDefinitions\n        .map((definition) => animateStyle.animateStyle(...definition))\n        .filter(Boolean);\n    return controls.withControls(animationFactories, options, \n    // Get the duration from the first animation definition\n    (_a = animationDefinitions[0]) === null || _a === void 0 ? void 0 : _a[3].duration);\n}\nfunction createAnimationsFromTimeline(definition, _a = {}) {\n    var { defaultOptions = {} } = _a, timelineOptions = tslib.__rest(_a, [\"defaultOptions\"]);\n    const animationDefinitions = [];\n    const elementSequences = new Map();\n    const elementCache = {};\n    const timeLabels = new Map();\n    let prevTime = 0;\n    let currentTime = 0;\n    let totalDuration = 0;\n    /**\n     * Build the timeline by mapping over the definition array and converting\n     * the definitions into keyframes and offsets with absolute time values.\n     * These will later get converted into relative offsets in a second pass.\n     */\n    for (let i = 0; i < definition.length; i++) {\n        const segment = definition[i];\n        /**\n         * If this is a timeline label, mark it and skip the rest of this iteration.\n         */\n        if (utils.isString(segment)) {\n            timeLabels.set(segment, currentTime);\n            continue;\n        }\n        else if (!Array.isArray(segment)) {\n            timeLabels.set(segment.name, calcTime.calcNextTime(currentTime, segment.at, prevTime, timeLabels));\n            continue;\n        }\n        const [elementDefinition, keyframes$1, options$1 = {}] = segment;\n        /**\n         * If a relative or absolute time value has been specified we need to resolve\n         * it in relation to the currentTime.\n         */\n        if (options$1.at !== undefined) {\n            currentTime = calcTime.calcNextTime(currentTime, options$1.at, prevTime, timeLabels);\n        }\n        /**\n         * Keep track of the maximum duration in this definition. This will be\n         * applied to currentTime once the definition has been parsed.\n         */\n        let maxDuration = 0;\n        /**\n         * Find all the elements specified in the definition and parse value\n         * keyframes from their timeline definitions.\n         */\n        const elements = resolveElements.resolveElements(elementDefinition, elementCache);\n        const numElements = elements.length;\n        for (let elementIndex = 0; elementIndex < numElements; elementIndex++) {\n            const element = elements[elementIndex];\n            const elementSequence = getElementSequence(element, elementSequences);\n            for (const key in keyframes$1) {\n                const valueSequence = getValueSequence(key, elementSequence);\n                let valueKeyframes = keyframes.keyframesList(keyframes$1[key]);\n                const valueOptions = options.getOptions(options$1, key);\n                let { duration = defaultOptions.duration || utils.defaults.duration, easing = defaultOptions.easing || utils.defaults.easing, } = valueOptions;\n                if (utils.isEasingGenerator(easing)) {\n                    const valueIsTransform = transforms.isTransform(key);\n                    heyListen.invariant(valueKeyframes.length === 2 || !valueIsTransform, \"spring must be provided 2 keyframes within timeline\");\n                    const custom = easing.createAnimation(valueKeyframes, \n                    // TODO We currently only support explicit keyframes\n                    // so this doesn't currently read from the DOM\n                    () => \"0\", valueIsTransform);\n                    easing = custom.easing;\n                    if (custom.keyframes !== undefined)\n                        valueKeyframes = custom.keyframes;\n                    if (custom.duration !== undefined)\n                        duration = custom.duration;\n                }\n                const delay = stagger.resolveOption(options$1.delay, elementIndex, numElements) || 0;\n                const startTime = currentTime + delay;\n                const targetTime = startTime + duration;\n                /**\n                 *\n                 */\n                let { offset = utils.defaultOffset(valueKeyframes.length) } = valueOptions;\n                /**\n                 * If there's only one offset of 0, fill in a second with length 1\n                 *\n                 * TODO: Ensure there's a test that covers this removal\n                 */\n                if (offset.length === 1 && offset[0] === 0) {\n                    offset[1] = 1;\n                }\n                /**\n                 * Fill out if offset if fewer offsets than keyframes\n                 */\n                const remainder = length - valueKeyframes.length;\n                remainder > 0 && utils.fillOffset(offset, remainder);\n                /**\n                 * If only one value has been set, ie [1], push a null to the start of\n                 * the keyframe array. This will let us mark a keyframe at this point\n                 * that will later be hydrated with the previous value.\n                 */\n                valueKeyframes.length === 1 && valueKeyframes.unshift(null);\n                /**\n                 * Add keyframes, mapping offsets to absolute time.\n                 */\n                edit.addKeyframes(valueSequence, valueKeyframes, easing, offset, startTime, targetTime);\n                maxDuration = Math.max(delay + duration, maxDuration);\n                totalDuration = Math.max(targetTime, totalDuration);\n            }\n        }\n        prevTime = currentTime;\n        currentTime += maxDuration;\n    }\n    /**\n     * For every element and value combination create a new animation.\n     */\n    elementSequences.forEach((valueSequences, element) => {\n        for (const key in valueSequences) {\n            const valueSequence = valueSequences[key];\n            /**\n             * Arrange all the keyframes in ascending time order.\n             */\n            valueSequence.sort(sort.compareByTime);\n            const keyframes = [];\n            const valueOffset = [];\n            const valueEasing = [];\n            /**\n             * For each keyframe, translate absolute times into\n             * relative offsets based on the total duration of the timeline.\n             */\n            for (let i = 0; i < valueSequence.length; i++) {\n                const { at, value, easing } = valueSequence[i];\n                keyframes.push(value);\n                valueOffset.push(utils.progress(0, totalDuration, at));\n                valueEasing.push(easing || utils.defaults.easing);\n            }\n            /**\n             * If the first keyframe doesn't land on offset: 0\n             * provide one by duplicating the initial keyframe. This ensures\n             * it snaps to the first keyframe when the animation starts.\n             */\n            if (valueOffset[0] !== 0) {\n                valueOffset.unshift(0);\n                keyframes.unshift(keyframes[0]);\n                valueEasing.unshift(\"linear\");\n            }\n            /**\n             * If the last keyframe doesn't land on offset: 1\n             * provide one with a null wildcard value. This will ensure it\n             * stays static until the end of the animation.\n             */\n            if (valueOffset[valueOffset.length - 1] !== 1) {\n                valueOffset.push(1);\n                keyframes.push(null);\n            }\n            animationDefinitions.push([\n                element,\n                key,\n                keyframes,\n                Object.assign(Object.assign(Object.assign({}, defaultOptions), { duration: totalDuration, easing: valueEasing, offset: valueOffset }), timelineOptions),\n            ]);\n        }\n    });\n    return animationDefinitions;\n}\nfunction getElementSequence(element, sequences) {\n    !sequences.has(element) && sequences.set(element, {});\n    return sequences.get(element);\n}\nfunction getValueSequence(name, sequences) {\n    if (!sequences[name])\n        sequences[name] = [];\n    return sequences[name];\n}\n\nexports.createAnimationsFromTimeline = createAnimationsFromTimeline;\nexports.timeline = timeline;\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$$motionone$dom$dist$animate$utils$transforms_cjs","~$module$node_modules$$motionone$dom$dist$utils$resolve_elements_cjs","~$module$node_modules$$motionone$dom$dist$animate$utils$options_cjs","~$module$node_modules$tslib$tslib","~$shadow.js","~$module$node_modules$hey_listen$dist$index","~$module$node_modules$$motionone$utils$dist$index_cjs","~$module$node_modules$$motionone$dom$dist$timeline$utils$sort_cjs","~$module$node_modules$$motionone$dom$dist$animate$utils$keyframes_cjs","~$module$node_modules$$motionone$dom$dist$utils$stagger_cjs","~$module$node_modules$$motionone$dom$dist$timeline$utils$calc_time_cjs","~$module$node_modules$$motionone$dom$dist$animate$animate_style_cjs","~$module$node_modules$$motionone$dom$dist$timeline$utils$edit_cjs","~$module$node_modules$$motionone$dom$dist$animate$utils$controls_cjs"]],"~:properties",["^5",["createAnimationsFromTimeline","easing","offset","timeline","__esModule","value","duration"]],"~:compiled-at",1681642524798,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$motionone$dom$dist$timeline$index_cjs.js\",\n\"lineCount\":11,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@motionone/dom/dist/timeline/index.cjs.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$$motionone$dom$dist$timeline$index_cjs\\\"] = function(global,require,module,exports) {\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', { value: true });\\n\\nvar tslib = require('tslib');\\nvar heyListen = require('hey-listen');\\nvar utils = require('@motionone/utils');\\nvar stagger = require('../utils/stagger.cjs.js');\\nvar animateStyle = require('../animate/animate-style.cjs.js');\\nvar controls = require('../animate/utils/controls.cjs.js');\\nvar keyframes = require('../animate/utils/keyframes.cjs.js');\\nvar options = require('../animate/utils/options.cjs.js');\\nvar resolveElements = require('../utils/resolve-elements.cjs.js');\\nvar transforms = require('../animate/utils/transforms.cjs.js');\\nvar calcTime = require('./utils/calc-time.cjs.js');\\nvar edit = require('./utils/edit.cjs.js');\\nvar sort = require('./utils/sort.cjs.js');\\n\\nfunction timeline(definition, options = {}) {\\n    var _a;\\n    const animationDefinitions = createAnimationsFromTimeline(definition, options);\\n    /**\\n     * Create and start animations\\n     */\\n    const animationFactories = animationDefinitions\\n        .map((definition) => animateStyle.animateStyle(...definition))\\n        .filter(Boolean);\\n    return controls.withControls(animationFactories, options, \\n    // Get the duration from the first animation definition\\n    (_a = animationDefinitions[0]) === null || _a === void 0 ? void 0 : _a[3].duration);\\n}\\nfunction createAnimationsFromTimeline(definition, _a = {}) {\\n    var { defaultOptions = {} } = _a, timelineOptions = tslib.__rest(_a, [\\\"defaultOptions\\\"]);\\n    const animationDefinitions = [];\\n    const elementSequences = new Map();\\n    const elementCache = {};\\n    const timeLabels = new Map();\\n    let prevTime = 0;\\n    let currentTime = 0;\\n    let totalDuration = 0;\\n    /**\\n     * Build the timeline by mapping over the definition array and converting\\n     * the definitions into keyframes and offsets with absolute time values.\\n     * These will later get converted into relative offsets in a second pass.\\n     */\\n    for (let i = 0; i < definition.length; i++) {\\n        const segment = definition[i];\\n        /**\\n         * If this is a timeline label, mark it and skip the rest of this iteration.\\n         */\\n        if (utils.isString(segment)) {\\n            timeLabels.set(segment, currentTime);\\n            continue;\\n        }\\n        else if (!Array.isArray(segment)) {\\n            timeLabels.set(segment.name, calcTime.calcNextTime(currentTime, segment.at, prevTime, timeLabels));\\n            continue;\\n        }\\n        const [elementDefinition, keyframes$1, options$1 = {}] = segment;\\n        /**\\n         * If a relative or absolute time value has been specified we need to resolve\\n         * it in relation to the currentTime.\\n         */\\n        if (options$1.at !== undefined) {\\n            currentTime = calcTime.calcNextTime(currentTime, options$1.at, prevTime, timeLabels);\\n        }\\n        /**\\n         * Keep track of the maximum duration in this definition. This will be\\n         * applied to currentTime once the definition has been parsed.\\n         */\\n        let maxDuration = 0;\\n        /**\\n         * Find all the elements specified in the definition and parse value\\n         * keyframes from their timeline definitions.\\n         */\\n        const elements = resolveElements.resolveElements(elementDefinition, elementCache);\\n        const numElements = elements.length;\\n        for (let elementIndex = 0; elementIndex < numElements; elementIndex++) {\\n            const element = elements[elementIndex];\\n            const elementSequence = getElementSequence(element, elementSequences);\\n            for (const key in keyframes$1) {\\n                const valueSequence = getValueSequence(key, elementSequence);\\n                let valueKeyframes = keyframes.keyframesList(keyframes$1[key]);\\n                const valueOptions = options.getOptions(options$1, key);\\n                let { duration = defaultOptions.duration || utils.defaults.duration, easing = defaultOptions.easing || utils.defaults.easing, } = valueOptions;\\n                if (utils.isEasingGenerator(easing)) {\\n                    const valueIsTransform = transforms.isTransform(key);\\n                    heyListen.invariant(valueKeyframes.length === 2 || !valueIsTransform, \\\"spring must be provided 2 keyframes within timeline\\\");\\n                    const custom = easing.createAnimation(valueKeyframes, \\n                    // TODO We currently only support explicit keyframes\\n                    // so this doesn't currently read from the DOM\\n                    () => \\\"0\\\", valueIsTransform);\\n                    easing = custom.easing;\\n                    if (custom.keyframes !== undefined)\\n                        valueKeyframes = custom.keyframes;\\n                    if (custom.duration !== undefined)\\n                        duration = custom.duration;\\n                }\\n                const delay = stagger.resolveOption(options$1.delay, elementIndex, numElements) || 0;\\n                const startTime = currentTime + delay;\\n                const targetTime = startTime + duration;\\n                /**\\n                 *\\n                 */\\n                let { offset = utils.defaultOffset(valueKeyframes.length) } = valueOptions;\\n                /**\\n                 * If there's only one offset of 0, fill in a second with length 1\\n                 *\\n                 * TODO: Ensure there's a test that covers this removal\\n                 */\\n                if (offset.length === 1 && offset[0] === 0) {\\n                    offset[1] = 1;\\n                }\\n                /**\\n                 * Fill out if offset if fewer offsets than keyframes\\n                 */\\n                const remainder = length - valueKeyframes.length;\\n                remainder > 0 && utils.fillOffset(offset, remainder);\\n                /**\\n                 * If only one value has been set, ie [1], push a null to the start of\\n                 * the keyframe array. This will let us mark a keyframe at this point\\n                 * that will later be hydrated with the previous value.\\n                 */\\n                valueKeyframes.length === 1 && valueKeyframes.unshift(null);\\n                /**\\n                 * Add keyframes, mapping offsets to absolute time.\\n                 */\\n                edit.addKeyframes(valueSequence, valueKeyframes, easing, offset, startTime, targetTime);\\n                maxDuration = Math.max(delay + duration, maxDuration);\\n                totalDuration = Math.max(targetTime, totalDuration);\\n            }\\n        }\\n        prevTime = currentTime;\\n        currentTime += maxDuration;\\n    }\\n    /**\\n     * For every element and value combination create a new animation.\\n     */\\n    elementSequences.forEach((valueSequences, element) => {\\n        for (const key in valueSequences) {\\n            const valueSequence = valueSequences[key];\\n            /**\\n             * Arrange all the keyframes in ascending time order.\\n             */\\n            valueSequence.sort(sort.compareByTime);\\n            const keyframes = [];\\n            const valueOffset = [];\\n            const valueEasing = [];\\n            /**\\n             * For each keyframe, translate absolute times into\\n             * relative offsets based on the total duration of the timeline.\\n             */\\n            for (let i = 0; i < valueSequence.length; i++) {\\n                const { at, value, easing } = valueSequence[i];\\n                keyframes.push(value);\\n                valueOffset.push(utils.progress(0, totalDuration, at));\\n                valueEasing.push(easing || utils.defaults.easing);\\n            }\\n            /**\\n             * If the first keyframe doesn't land on offset: 0\\n             * provide one by duplicating the initial keyframe. This ensures\\n             * it snaps to the first keyframe when the animation starts.\\n             */\\n            if (valueOffset[0] !== 0) {\\n                valueOffset.unshift(0);\\n                keyframes.unshift(keyframes[0]);\\n                valueEasing.unshift(\\\"linear\\\");\\n            }\\n            /**\\n             * If the last keyframe doesn't land on offset: 1\\n             * provide one with a null wildcard value. This will ensure it\\n             * stays static until the end of the animation.\\n             */\\n            if (valueOffset[valueOffset.length - 1] !== 1) {\\n                valueOffset.push(1);\\n                keyframes.push(null);\\n            }\\n            animationDefinitions.push([\\n                element,\\n                key,\\n                keyframes,\\n                Object.assign(Object.assign(Object.assign({}, defaultOptions), { duration: totalDuration, easing: valueEasing, offset: valueOffset }), timelineOptions),\\n            ]);\\n        }\\n    });\\n    return animationDefinitions;\\n}\\nfunction getElementSequence(element, sequences) {\\n    !sequences.has(element) && sequences.set(element, {});\\n    return sequences.get(element);\\n}\\nfunction getValueSequence(name, sequences) {\\n    if (!sequences[name])\\n        sequences[name] = [];\\n    return sequences[name];\\n}\\n\\nexports.createAnimationsFromTimeline = createAnimationsFromTimeline;\\nexports.timeline = timeline;\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"createAnimationsFromTimeline\",\"definition\",\"_a\",\"defaultOptions\",\"timelineOptions\",\"tslib\",\"__rest\",\"animationDefinitions\",\"elementSequences\",\"Map\",\"elementCache\",\"timeLabels\",\"prevTime\",\"currentTime\",\"totalDuration\",\"i\",\"length\",\"segment\",\"utils\",\"isString\",\"set\",\"Array\",\"isArray\",\"name\",\"calcTime\",\"calcNextTime\",\"at\",\"elementDefinition\",\"keyframes$1\",\"options$1\",\"undefined\",\"maxDuration\",\"elements\",\"resolveElements\",\"numElements\",\"elementIndex\",\"elementSequence\",\"getElementSequence\",\"element\",\"key\",\"valueSequence\",\"getValueSequence\",\"valueKeyframes\",\"keyframes\",\"keyframesList\",\"valueOptions\",\"options\",\"getOptions\",\"duration\",\"defaults\",\"easing\",\"isEasingGenerator\",\"valueIsTransform\",\"transforms\",\"isTransform\",\"heyListen\",\"invariant\",\"custom\",\"createAnimation\",\"delay\",\"stagger\",\"resolveOption\",\"startTime\",\"targetTime\",\"offset\",\"defaultOffset\",\"remainder\",\"fillOffset\",\"unshift\",\"edit\",\"addKeyframes\",\"Math\",\"max\",\"forEach\",\"valueSequences\",\"sort\",\"compareByTime\",\"valueOffset\",\"valueEasing\",\"value\",\"push\",\"progress\",\"Object\",\"assign\",\"sequences\",\"has\",\"get\",\"defineProperty\",\"animateStyle\",\"controls\",\"timeline\",\"animationFactories\",\"map\",\"filter\",\"Boolean\",\"withControls\"]\n}\n"]