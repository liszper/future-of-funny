{
"version":3,
"file":"module$node_modules$socket_DOT_io_parser$build$cjs$index.js",
"lineCount":9,
"mappings":"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",
"sources":["node_modules/socket_DOT_io-parser/build/cjs/index.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$socket_DOT_io_parser$build$cjs$index\"] = function(global,require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Decoder = exports.Encoder = exports.PacketType = exports.protocol = void 0;\nconst component_emitter_1 = require(\"@socket.io/component-emitter\");\nconst binary_js_1 = require(\"./binary.js\");\nconst is_binary_js_1 = require(\"./is-binary.js\");\nconst debug_1 = require(\"debug\"); // debug()\nconst debug = debug_1.default(\"socket.io-parser\"); // debug()\n/**\n * Protocol version.\n *\n * @public\n */\nexports.protocol = 5;\nvar PacketType;\n(function (PacketType) {\n    PacketType[PacketType[\"CONNECT\"] = 0] = \"CONNECT\";\n    PacketType[PacketType[\"DISCONNECT\"] = 1] = \"DISCONNECT\";\n    PacketType[PacketType[\"EVENT\"] = 2] = \"EVENT\";\n    PacketType[PacketType[\"ACK\"] = 3] = \"ACK\";\n    PacketType[PacketType[\"CONNECT_ERROR\"] = 4] = \"CONNECT_ERROR\";\n    PacketType[PacketType[\"BINARY_EVENT\"] = 5] = \"BINARY_EVENT\";\n    PacketType[PacketType[\"BINARY_ACK\"] = 6] = \"BINARY_ACK\";\n})(PacketType = exports.PacketType || (exports.PacketType = {}));\n/**\n * A socket.io Encoder instance\n */\nclass Encoder {\n    /**\n     * Encoder constructor\n     *\n     * @param {function} replacer - custom replacer to pass down to JSON.parse\n     */\n    constructor(replacer) {\n        this.replacer = replacer;\n    }\n    /**\n     * Encode a packet as a single string if non-binary, or as a\n     * buffer sequence, depending on packet type.\n     *\n     * @param {Object} obj - packet object\n     */\n    encode(obj) {\n        debug(\"encoding packet %j\", obj);\n        if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {\n            if (is_binary_js_1.hasBinary(obj)) {\n                obj.type =\n                    obj.type === PacketType.EVENT\n                        ? PacketType.BINARY_EVENT\n                        : PacketType.BINARY_ACK;\n                return this.encodeAsBinary(obj);\n            }\n        }\n        return [this.encodeAsString(obj)];\n    }\n    /**\n     * Encode packet as string.\n     */\n    encodeAsString(obj) {\n        // first is type\n        let str = \"\" + obj.type;\n        // attachments if we have them\n        if (obj.type === PacketType.BINARY_EVENT ||\n            obj.type === PacketType.BINARY_ACK) {\n            str += obj.attachments + \"-\";\n        }\n        // if we have a namespace other than `/`\n        // we append it followed by a comma `,`\n        if (obj.nsp && \"/\" !== obj.nsp) {\n            str += obj.nsp + \",\";\n        }\n        // immediately followed by the id\n        if (null != obj.id) {\n            str += obj.id;\n        }\n        // json data\n        if (null != obj.data) {\n            str += JSON.stringify(obj.data, this.replacer);\n        }\n        debug(\"encoded %j as %s\", obj, str);\n        return str;\n    }\n    /**\n     * Encode packet as 'buffer sequence' by removing blobs, and\n     * deconstructing packet into object with placeholders and\n     * a list of buffers.\n     */\n    encodeAsBinary(obj) {\n        const deconstruction = binary_js_1.deconstructPacket(obj);\n        const pack = this.encodeAsString(deconstruction.packet);\n        const buffers = deconstruction.buffers;\n        buffers.unshift(pack); // add packet info to beginning of data list\n        return buffers; // write all the buffers\n    }\n}\nexports.Encoder = Encoder;\n/**\n * A socket.io Decoder instance\n *\n * @return {Object} decoder\n */\nclass Decoder extends component_emitter_1.Emitter {\n    /**\n     * Decoder constructor\n     *\n     * @param {function} reviver - custom reviver to pass down to JSON.stringify\n     */\n    constructor(reviver) {\n        super();\n        this.reviver = reviver;\n    }\n    /**\n     * Decodes an encoded packet string into packet JSON.\n     *\n     * @param {String} obj - encoded packet\n     */\n    add(obj) {\n        let packet;\n        if (typeof obj === \"string\") {\n            if (this.reconstructor) {\n                throw new Error(\"got plaintext data when reconstructing a packet\");\n            }\n            packet = this.decodeString(obj);\n            if (packet.type === PacketType.BINARY_EVENT ||\n                packet.type === PacketType.BINARY_ACK) {\n                // binary packet's json\n                this.reconstructor = new BinaryReconstructor(packet);\n                // no attachments, labeled binary but no binary data to follow\n                if (packet.attachments === 0) {\n                    super.emitReserved(\"decoded\", packet);\n                }\n            }\n            else {\n                // non-binary full packet\n                super.emitReserved(\"decoded\", packet);\n            }\n        }\n        else if (is_binary_js_1.isBinary(obj) || obj.base64) {\n            // raw binary data\n            if (!this.reconstructor) {\n                throw new Error(\"got binary data when not reconstructing a packet\");\n            }\n            else {\n                packet = this.reconstructor.takeBinaryData(obj);\n                if (packet) {\n                    // received final buffer\n                    this.reconstructor = null;\n                    super.emitReserved(\"decoded\", packet);\n                }\n            }\n        }\n        else {\n            throw new Error(\"Unknown type: \" + obj);\n        }\n    }\n    /**\n     * Decode a packet String (JSON data)\n     *\n     * @param {String} str\n     * @return {Object} packet\n     */\n    decodeString(str) {\n        let i = 0;\n        // look up type\n        const p = {\n            type: Number(str.charAt(0)),\n        };\n        if (PacketType[p.type] === undefined) {\n            throw new Error(\"unknown packet type \" + p.type);\n        }\n        // look up attachments if type binary\n        if (p.type === PacketType.BINARY_EVENT ||\n            p.type === PacketType.BINARY_ACK) {\n            const start = i + 1;\n            while (str.charAt(++i) !== \"-\" && i != str.length) { }\n            const buf = str.substring(start, i);\n            if (buf != Number(buf) || str.charAt(i) !== \"-\") {\n                throw new Error(\"Illegal attachments\");\n            }\n            p.attachments = Number(buf);\n        }\n        // look up namespace (if any)\n        if (\"/\" === str.charAt(i + 1)) {\n            const start = i + 1;\n            while (++i) {\n                const c = str.charAt(i);\n                if (\",\" === c)\n                    break;\n                if (i === str.length)\n                    break;\n            }\n            p.nsp = str.substring(start, i);\n        }\n        else {\n            p.nsp = \"/\";\n        }\n        // look up id\n        const next = str.charAt(i + 1);\n        if (\"\" !== next && Number(next) == next) {\n            const start = i + 1;\n            while (++i) {\n                const c = str.charAt(i);\n                if (null == c || Number(c) != c) {\n                    --i;\n                    break;\n                }\n                if (i === str.length)\n                    break;\n            }\n            p.id = Number(str.substring(start, i + 1));\n        }\n        // look up json data\n        if (str.charAt(++i)) {\n            const payload = this.tryParse(str.substr(i));\n            if (Decoder.isPayloadValid(p.type, payload)) {\n                p.data = payload;\n            }\n            else {\n                throw new Error(\"invalid payload\");\n            }\n        }\n        debug(\"decoded %s as %j\", str, p);\n        return p;\n    }\n    tryParse(str) {\n        try {\n            return JSON.parse(str, this.reviver);\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    static isPayloadValid(type, payload) {\n        switch (type) {\n            case PacketType.CONNECT:\n                return typeof payload === \"object\";\n            case PacketType.DISCONNECT:\n                return payload === undefined;\n            case PacketType.CONNECT_ERROR:\n                return typeof payload === \"string\" || typeof payload === \"object\";\n            case PacketType.EVENT:\n            case PacketType.BINARY_EVENT:\n                return Array.isArray(payload) && payload.length > 0;\n            case PacketType.ACK:\n            case PacketType.BINARY_ACK:\n                return Array.isArray(payload);\n        }\n    }\n    /**\n     * Deallocates a parser's resources\n     */\n    destroy() {\n        if (this.reconstructor) {\n            this.reconstructor.finishedReconstruction();\n        }\n    }\n}\nexports.Decoder = Decoder;\n/**\n * A manager of a binary event's 'buffer sequence'. Should\n * be constructed whenever a packet of type BINARY_EVENT is\n * decoded.\n *\n * @param {Object} packet\n * @return {BinaryReconstructor} initialized reconstructor\n */\nclass BinaryReconstructor {\n    constructor(packet) {\n        this.packet = packet;\n        this.buffers = [];\n        this.reconPack = packet;\n    }\n    /**\n     * Method to be called when binary data received from connection\n     * after a BINARY_EVENT packet.\n     *\n     * @param {Buffer | ArrayBuffer} binData - the raw binary data received\n     * @return {null | Object} returns null if more binary data is expected or\n     *   a reconstructed packet object if all buffers have been received.\n     */\n    takeBinaryData(binData) {\n        this.buffers.push(binData);\n        if (this.buffers.length === this.reconPack.attachments) {\n            // done with buffer list\n            const packet = binary_js_1.reconstructPacket(this.reconPack, this.buffers);\n            this.finishedReconstruction();\n            return packet;\n        }\n        return null;\n    }\n    /**\n     * Cleans up binary packet reconstruction variables.\n     */\n    finishedReconstruction() {\n        this.reconPack = null;\n        this.buffers = [];\n    }\n}\n\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","Decoder","Encoder","PacketType","protocol","component_emitter_1","binary_js_1","is_binary_js_1","debug","debug_1","default","constructor","replacer","encode","obj","type","EVENT","ACK","hasBinary","encodeAsString","BINARY_EVENT","BINARY_ACK","encodeAsBinary","str","attachments","nsp","id","data","JSON","stringify","deconstruction","deconstructPacket","pack","packet","buffers","unshift","Emitter","reviver","add","reconstructor","Error","decodeString","BinaryReconstructor","emitReserved","isBinary","base64","takeBinaryData","i","p","Number","charAt","undefined","start","length","buf","substring","c","next","payload","tryParse","substr","isPayloadValid","parse","e","CONNECT","DISCONNECT","CONNECT_ERROR","Array","isArray","destroy","finishedReconstruction","reconPack","binData","push","reconstructPacket"]
}
