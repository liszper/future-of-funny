'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = function () {
  return wrap({});
};

var _scheduler = require('./scheduler');

var _functions = require('./functions');

var functions = _interopRequireWildcard(_functions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Composes all the defined functions and wraps them
 * so they always return wrapper instead of options object
 *
 * @param  {Object} opt Options object
 * @return {Object}     Object containing all the wrapped functions
 */
function wrapFunctions(opt) {
  return Object.keys(functions).reduce(function (composed, f) {
    return _extends({}, composed, _defineProperty({}, f, function () {
      return wrap(_extends({}, opt, _defineProperty({}, f, functions[f].apply(functions, arguments))));
    }));
  }, {});
}

/**
 * Wraps options object with predefined functions
 *
 * @param  {Object} opt Options object
 * @return {Object}     Object containing all the wrapped functions
 */
function wrap(opt) {
  return _extends({}, wrapFunctions(opt), {

    GetExecutionDatesAfter: function GetExecutionDatesAfter(date, numberOfDates) {
      return (0, _scheduler.getExecutionDatesAfter)(date, resolveOptions(opt, (0, _scheduler.create)()), numberOfDates);
    },

    OnFire: function OnFire(cb) {
      return wrap((0, _scheduler.onFire)(cb, opt));
    },

    Start: function Start() {
      var when = arguments.length <= 0 || arguments[0] === undefined ? new Date() : arguments[0];
      return (0, _scheduler.start)(when, resolveOptions(opt, (0, _scheduler.create)()));
    }
  });
}

function resolveOptions(props, initialOpt) {

  var opt = Object.keys(props).map(function (e) {
    return props[e];
  }).sort(function (a, b) {
    return b.resolution - a.resolution;
  }).reduce(function (c, e) {
    return e.execute ? e.execute(c) : _extends({}, c, e);
  }, initialOpt);

  return opt;
}

/**
 * Creates new trigger
 *
 * @return {Object} Wrapper over newly created triggerOut
 *                  Exposing number of functions
 */