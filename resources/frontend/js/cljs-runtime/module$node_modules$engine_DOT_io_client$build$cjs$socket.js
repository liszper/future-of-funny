shadow$provide.module$node_modules$engine_DOT_io_client$build$cjs$socket=function(global,require,module,exports){global=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{"default":mod}};Object.defineProperty(exports,"__esModule",{value:!0});exports.Socket=void 0;const index_js_1=require("module$node_modules$engine_DOT_io_client$build$cjs$transports$index"),util_js_1=require("module$node_modules$engine_DOT_io_client$build$cjs$util"),parseqs_js_1=require("module$node_modules$engine_DOT_io_client$build$cjs$contrib$parseqs"),
parseuri_js_1=require("module$node_modules$engine_DOT_io_client$build$cjs$contrib$parseuri");global=global(require("module$node_modules$engine_DOT_io_client$node_modules$debug$src$browser"));module=require("module$node_modules$$socket_DOT_io$component_emitter$index");const engine_io_parser_1=require("module$node_modules$engine_DOT_io_parser$build$cjs$index"),debug=(0,global.default)("engine.io-client:socket");class Socket extends module.Emitter{constructor(uri,opts={}){super();uri&&"object"===typeof uri&&
(opts=uri,uri=null);uri?(uri=(0,parseuri_js_1.parse)(uri),opts.hostname=uri.host,opts.secure="https"===uri.protocol||"wss"===uri.protocol,opts.port=uri.port,uri.query&&(opts.query=uri.query)):opts.host&&(opts.hostname=(0,parseuri_js_1.parse)(opts.host).host);(0,util_js_1.installTimerFunctions)(this,opts);this.secure=null!=opts.secure?opts.secure:"undefined"!==typeof location&&"https:"===location.protocol;opts.hostname&&!opts.port&&(opts.port=this.secure?"443":"80");this.hostname=opts.hostname||("undefined"!==
typeof location?location.hostname:"localhost");this.port=opts.port||("undefined"!==typeof location&&location.port?location.port:this.secure?"443":"80");this.transports=opts.transports||["polling","websocket"];this.readyState="";this.writeBuffer=[];this.prevBufferLen=0;this.opts=Object.assign({path:"/engine.io",agent:!1,withCredentials:!1,upgrade:!0,timestampParam:"t",rememberUpgrade:!1,rejectUnauthorized:!0,perMessageDeflate:{threshold:1024},transportOptions:{},closeOnBeforeunload:!0},opts);this.opts.path=
this.opts.path.replace(/\/$/,"")+"/";"string"===typeof this.opts.query&&(this.opts.query=(0,parseqs_js_1.decode)(this.opts.query));this.pingTimeoutTimer=this.pingTimeout=this.pingInterval=this.upgrades=this.id=null;"function"===typeof addEventListener&&(this.opts.closeOnBeforeunload&&(this.beforeunloadEventListener=()=>{this.transport&&(this.transport.removeAllListeners(),this.transport.close())},addEventListener("beforeunload",this.beforeunloadEventListener,!1)),"localhost"!==this.hostname&&(this.offlineEventListener=
()=>{this.onClose("transport close",{description:"network connection lost"})},addEventListener("offline",this.offlineEventListener,!1)));this.open()}createTransport(name){debug('creating transport "%s"',name);var query=Object.assign({},this.opts.query);query.EIO=engine_io_parser_1.protocol;query.transport=name;this.id&&(query.sid=this.id);query=Object.assign({},this.opts.transportOptions[name],this.opts,{query,socket:this,hostname:this.hostname,secure:this.secure,port:this.port});debug("options: %j",
query);return new index_js_1.transports[name](query)}open(){let transport;if(this.opts.rememberUpgrade&&Socket.priorWebsocketSuccess&&-1!==this.transports.indexOf("websocket"))transport="websocket";else{if(0===this.transports.length){this.setTimeoutFn(()=>{this.emitReserved("error","No transports available")},0);return}transport=this.transports[0]}this.readyState="opening";try{transport=this.createTransport(transport)}catch(e){debug("error while creating transport: %s",e);this.transports.shift();
this.open();return}transport.open();this.setTransport(transport)}setTransport(transport){debug("setting transport %s",transport.name);this.transport&&(debug("clearing existing transport %s",this.transport.name),this.transport.removeAllListeners());this.transport=transport;transport.on("drain",this.onDrain.bind(this)).on("packet",this.onPacket.bind(this)).on("error",this.onError.bind(this)).on("close",reason=>this.onClose("transport close",reason))}probe(name){function freezeTransport(){failed||(failed=
!0,cleanup(),transport.close(),transport=null)}function onTransportClose(){onerror("transport closed")}function onclose(){onerror("socket closed")}function onupgrade(to){transport&&to.name!==transport.name&&(debug('"%s" works - aborting "%s"',to.name,transport.name),freezeTransport())}debug('probing transport "%s"',name);let transport=this.createTransport(name),failed=!1;Socket.priorWebsocketSuccess=!1;const onTransportOpen=()=>{failed||(debug('probe transport "%s" opened',name),transport.send([{type:"ping",
data:"probe"}]),transport.once("packet",msg=>{failed||("pong"===msg.type&&"probe"===msg.data?(debug('probe transport "%s" pong',name),this.upgrading=!0,this.emitReserved("upgrading",transport),transport&&(Socket.priorWebsocketSuccess="websocket"===transport.name,debug('pausing current transport "%s"',this.transport.name),this.transport.pause(()=>{failed||"closed"===this.readyState||(debug("changing transport and sending upgrade packet"),cleanup(),this.setTransport(transport),transport.send([{type:"upgrade"}]),
this.emitReserved("upgrade",transport),transport=null,this.upgrading=!1,this.flush())}))):(debug('probe transport "%s" failed',name),msg=Error("probe error"),msg.transport=transport.name,this.emitReserved("upgradeError",msg)))}))},onerror=err=>{const error=Error("probe error: "+err);error.transport=transport.name;freezeTransport();debug('probe transport "%s" failed because of error: %s',name,err);this.emitReserved("upgradeError",error)},cleanup=()=>{transport.removeListener("open",onTransportOpen);
transport.removeListener("error",onerror);transport.removeListener("close",onTransportClose);this.off("close",onclose);this.off("upgrading",onupgrade)};transport.once("open",onTransportOpen);transport.once("error",onerror);transport.once("close",onTransportClose);this.once("close",onclose);this.once("upgrading",onupgrade);transport.open()}onOpen(){debug("socket open");this.readyState="open";Socket.priorWebsocketSuccess="websocket"===this.transport.name;this.emitReserved("open");this.flush();if("open"===
this.readyState&&this.opts.upgrade&&this.transport.pause){debug("starting upgrade probes");let i=0;const l=this.upgrades.length;for(;i<l;i++)this.probe(this.upgrades[i])}}onPacket(packet){if("opening"===this.readyState||"open"===this.readyState||"closing"===this.readyState)switch(debug('socket receive: type "%s", data "%s"',packet.type,packet.data),this.emitReserved("packet",packet),this.emitReserved("heartbeat"),packet.type){case "open":this.onHandshake(JSON.parse(packet.data));break;case "ping":this.resetPingTimeout();
this.sendPacket("pong");this.emitReserved("ping");this.emitReserved("pong");break;case "error":const err=Error("server error");err.code=packet.data;this.onError(err);break;case "message":this.emitReserved("data",packet.data),this.emitReserved("message",packet.data)}else debug('packet received with socket readyState "%s"',this.readyState)}onHandshake(data){this.emitReserved("handshake",data);this.id=data.sid;this.transport.query.sid=data.sid;this.upgrades=this.filterUpgrades(data.upgrades);this.pingInterval=
data.pingInterval;this.pingTimeout=data.pingTimeout;this.maxPayload=data.maxPayload;this.onOpen();"closed"!==this.readyState&&this.resetPingTimeout()}resetPingTimeout(){this.clearTimeoutFn(this.pingTimeoutTimer);this.pingTimeoutTimer=this.setTimeoutFn(()=>{this.onClose("ping timeout")},this.pingInterval+this.pingTimeout);this.opts.autoUnref&&this.pingTimeoutTimer.unref()}onDrain(){this.writeBuffer.splice(0,this.prevBufferLen);this.prevBufferLen=0;0===this.writeBuffer.length?this.emitReserved("drain"):
this.flush()}flush(){if("closed"!==this.readyState&&this.transport.writable&&!this.upgrading&&this.writeBuffer.length){const packets=this.getWritablePackets();debug("flushing %d packets in socket",packets.length);this.transport.send(packets);this.prevBufferLen=packets.length;this.emitReserved("flush")}}getWritablePackets(){if(!(this.maxPayload&&"polling"===this.transport.name&&1<this.writeBuffer.length))return this.writeBuffer;let payloadSize=1;for(let i=0;i<this.writeBuffer.length;i++){const data=
this.writeBuffer[i].data;data&&(payloadSize+=(0,util_js_1.byteLength)(data));if(0<i&&payloadSize>this.maxPayload)return debug("only send %d out of %d packets",i,this.writeBuffer.length),this.writeBuffer.slice(0,i);payloadSize+=2}debug("payload size is %d (max: %d)",payloadSize,this.maxPayload);return this.writeBuffer}write(msg,options,fn){this.sendPacket("message",msg,options,fn);return this}send(msg,options,fn){this.sendPacket("message",msg,options,fn);return this}sendPacket(type,data,options,fn){"function"===
typeof data&&(fn=data,data=void 0);"function"===typeof options&&(fn=options,options=null);if("closing"!==this.readyState&&"closed"!==this.readyState){options=options||{};options.compress=!1!==options.compress;type={type,data,options};this.emitReserved("packetCreate",type);this.writeBuffer.push(type);if(fn)this.once("flush",fn);this.flush()}}close(){const close=()=>{this.onClose("forced close");debug("socket closing - telling transport to close");this.transport.close()},cleanupAndClose=()=>{this.off("upgrade",
cleanupAndClose);this.off("upgradeError",cleanupAndClose);close()},waitForUpgrade=()=>{this.once("upgrade",cleanupAndClose);this.once("upgradeError",cleanupAndClose)};if("opening"===this.readyState||"open"===this.readyState)if(this.readyState="closing",this.writeBuffer.length)this.once("drain",()=>{this.upgrading?waitForUpgrade():close()});else this.upgrading?waitForUpgrade():close();return this}onError(err){debug("socket error %j",err);Socket.priorWebsocketSuccess=!1;this.emitReserved("error",err);
this.onClose("transport error",err)}onClose(reason,description){if("opening"===this.readyState||"open"===this.readyState||"closing"===this.readyState)debug('socket close with reason: "%s"',reason),this.clearTimeoutFn(this.pingTimeoutTimer),this.transport.removeAllListeners("close"),this.transport.close(),this.transport.removeAllListeners(),"function"===typeof removeEventListener&&(removeEventListener("beforeunload",this.beforeunloadEventListener,!1),removeEventListener("offline",this.offlineEventListener,
!1)),this.readyState="closed",this.id=null,this.emitReserved("close",reason,description),this.writeBuffer=[],this.prevBufferLen=0}filterUpgrades(upgrades){const filteredUpgrades=[];let i=0;const j=upgrades.length;for(;i<j;i++)~this.transports.indexOf(upgrades[i])&&filteredUpgrades.push(upgrades[i]);return filteredUpgrades}}exports.Socket=Socket;Socket.protocol=engine_io_parser_1.protocol}
//# sourceMappingURL=module$node_modules$engine_DOT_io_client$build$cjs$socket.js.map
