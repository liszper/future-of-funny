["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@motionone/utils/dist/interpolate.cjs.js"],"~:js","shadow$provide.module$node_modules$$motionone$utils$dist$interpolate_cjs=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});var mix=require(\"module$node_modules$$motionone$utils$dist$mix_cjs\"),noop=require(\"module$node_modules$$motionone$utils$dist$noop_cjs\"),offset=require(\"module$node_modules$$motionone$utils$dist$offset_cjs\"),progress=require(\"module$node_modules$$motionone$utils$dist$progress_cjs\"),easing=require(\"module$node_modules$$motionone$utils$dist$easing_cjs\"),\nclamp=require(\"module$node_modules$$motionone$utils$dist$clamp_cjs\");exports.interpolate=function(output,input=offset.defaultOffset(output.length),easing$1=noop.noopReturn){const length=output.length,remainder=length-input.length;0<remainder&&offset.fillOffset(input,remainder);return t=>{let i=0;for(;i<length-2&&!(t<input[i+1]);i++);t=clamp.clamp(0,1,progress.progress(input[i],input[i+1],t));t=easing.getEasingForSegment(easing$1,i)(t);return mix.mix(output[i],output[i+1],t)}}}","~:source","shadow$provide[\"module$node_modules$$motionone$utils$dist$interpolate_cjs\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar mix = require('./mix.cjs.js');\nvar noop = require('./noop.cjs.js');\nvar offset = require('./offset.cjs.js');\nvar progress = require('./progress.cjs.js');\nvar easing = require('./easing.cjs.js');\nvar clamp = require('./clamp.cjs.js');\n\nfunction interpolate(output, input = offset.defaultOffset(output.length), easing$1 = noop.noopReturn) {\n    const length = output.length;\n    /**\n     * If the input length is lower than the output we\n     * fill the input to match. This currently assumes the input\n     * is an animation progress value so is a good candidate for\n     * moving outside the function.\n     */\n    const remainder = length - input.length;\n    remainder > 0 && offset.fillOffset(input, remainder);\n    return (t) => {\n        let i = 0;\n        for (; i < length - 2; i++) {\n            if (t < input[i + 1])\n                break;\n        }\n        let progressInRange = clamp.clamp(0, 1, progress.progress(input[i], input[i + 1], t));\n        const segmentEasing = easing.getEasingForSegment(easing$1, i);\n        progressInRange = segmentEasing(progressInRange);\n        return mix.mix(output[i], output[i + 1], progressInRange);\n    };\n}\n\nexports.interpolate = interpolate;\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$$motionone$utils$dist$easing_cjs","~$module$node_modules$$motionone$utils$dist$mix_cjs","~$module$node_modules$$motionone$utils$dist$noop_cjs","~$shadow.js","~$module$node_modules$$motionone$utils$dist$clamp_cjs","~$module$node_modules$$motionone$utils$dist$progress_cjs","~$module$node_modules$$motionone$utils$dist$offset_cjs"]],"~:properties",["^5",["interpolate","__esModule","value"]],"~:compiled-at",1681642524792,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$motionone$utils$dist$interpolate_cjs.js\",\n\"lineCount\":2,\n\"mappings\":\"AAAAA,cAAA,CAAA,yDAAA,CAA8E,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAGtHC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAAEG,MAAO,CAAA,CAAT,CAA7C,CAEA,KAAIC,IAAMN,OAAA,CAAQ,mDAAR,CAAV,CACIO,KAAOP,OAAA,CAAQ,oDAAR,CADX,CAEIQ,OAASR,OAAA,CAAQ,sDAAR,CAFb,CAGIS,SAAWT,OAAA,CAAQ,wDAAR,CAHf,CAIIU,OAASV,OAAA,CAAQ,sDAAR,CAJb;AAKIW,MAAQX,OAAA,CAAQ,qDAAR,CAyBZE,QAAQU,CAAAA,WAAR,CAvBAA,QAAoB,CAACC,MAAD,CAASC,KAAA,CAAQN,MAAOO,CAAAA,aAAP,CAAqBF,MAAOG,CAAAA,MAA5B,CAAjB,CAAsDC,QAAA,CAAWV,IAAKW,CAAAA,UAAtE,CAAkF,CAClG,MAAMF,OAASH,MAAOG,CAAAA,MAAtB,CAOMG,UAAYH,MAAZG,CAAqBL,KAAME,CAAAA,MACrB,EAAZ,CAAAG,SAAA,EAAiBX,MAAOY,CAAAA,UAAP,CAAkBN,KAAlB,CAAyBK,SAAzB,CACjB,OAAQE,EAAD,EAAO,CACV,IAAIC,EAAI,CACR,KAAA,CAAOA,CAAP,CAAWN,MAAX,CAAoB,CAApB,EACQ,EAAAK,CAAA,CAAIP,KAAA,CAAMQ,CAAN,CAAU,CAAV,CAAJ,CADR,CAAuBA,CAAA,EAAvB,EAIIC,CAAAA,CAAkBZ,KAAMA,CAAAA,KAAN,CAAY,CAAZ,CAAe,CAAf,CAAkBF,QAASA,CAAAA,QAAT,CAAkBK,KAAA,CAAMQ,CAAN,CAAlB,CAA4BR,KAAA,CAAMQ,CAAN,CAAU,CAAV,CAA5B,CAA0CD,CAA1C,CAAlB,CAEtBE,EAAA,CADsBb,MAAOc,CAAAA,mBAAPC,CAA2BR,QAA3BQ,CAAqCH,CAArCG,CACJ,CAAcF,CAAd,CAClB,OAAOjB,IAAIA,CAAAA,GAAJ,CAAQO,MAAA,CAAOS,CAAP,CAAR,CAAmBT,MAAA,CAAOS,CAAP,CAAW,CAAX,CAAnB,CAAkCC,CAAlC,CATG,CAVoF,CAZgB;\",\n\"sources\":[\"node_modules/@motionone/utils/dist/interpolate.cjs.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$$motionone$utils$dist$interpolate_cjs\\\"] = function(global,require,module,exports) {\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', { value: true });\\n\\nvar mix = require('./mix.cjs.js');\\nvar noop = require('./noop.cjs.js');\\nvar offset = require('./offset.cjs.js');\\nvar progress = require('./progress.cjs.js');\\nvar easing = require('./easing.cjs.js');\\nvar clamp = require('./clamp.cjs.js');\\n\\nfunction interpolate(output, input = offset.defaultOffset(output.length), easing$1 = noop.noopReturn) {\\n    const length = output.length;\\n    /**\\n     * If the input length is lower than the output we\\n     * fill the input to match. This currently assumes the input\\n     * is an animation progress value so is a good candidate for\\n     * moving outside the function.\\n     */\\n    const remainder = length - input.length;\\n    remainder > 0 && offset.fillOffset(input, remainder);\\n    return (t) => {\\n        let i = 0;\\n        for (; i < length - 2; i++) {\\n            if (t < input[i + 1])\\n                break;\\n        }\\n        let progressInRange = clamp.clamp(0, 1, progress.progress(input[i], input[i + 1], t));\\n        const segmentEasing = easing.getEasingForSegment(easing$1, i);\\n        progressInRange = segmentEasing(progressInRange);\\n        return mix.mix(output[i], output[i + 1], progressInRange);\\n    };\\n}\\n\\nexports.interpolate = interpolate;\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"mix\",\"noop\",\"offset\",\"progress\",\"easing\",\"clamp\",\"interpolate\",\"output\",\"input\",\"defaultOffset\",\"length\",\"easing$1\",\"noopReturn\",\"remainder\",\"fillOffset\",\"t\",\"i\",\"progressInRange\",\"getEasingForSegment\",\"segmentEasing\"]\n}\n"]