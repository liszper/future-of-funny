shadow$provide.module$node_modules$socket_DOT_io_client$build$cjs$manager=function(global,require,module,exports){var __createBinding=this&&this.__createBinding||(Object.create?function(o,m,k,k2){void 0===k2&&(k2=k);Object.defineProperty(o,k2,{enumerable:!0,get:function(){return m[k]}})}:function(o,m,k,k2){void 0===k2&&(k2=k);o[k2]=m[k]}),__setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(o,v){Object.defineProperty(o,"default",{enumerable:!0,value:v})}:function(o,v){o["default"]=
v});module=this&&this.__importStar||function(mod){if(mod&&mod.__esModule)return mod;var result={};if(null!=mod)for(var k in mod)"default"!==k&&Object.prototype.hasOwnProperty.call(mod,k)&&__createBinding(result,mod,k);__setModuleDefault(result,mod);return result};global=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{"default":mod}};Object.defineProperty(exports,"__esModule",{value:!0});exports.Manager=void 0;const engine_io_client_1=require("module$node_modules$engine_DOT_io_client$build$cjs$index"),
socket_js_1=require("module$node_modules$socket_DOT_io_client$build$cjs$socket"),parser=module(require("module$node_modules$socket_DOT_io_parser$build$cjs$index")),on_js_1=require("module$node_modules$socket_DOT_io_client$build$cjs$on"),backo2_js_1=require("module$node_modules$socket_DOT_io_client$build$cjs$contrib$backo2");module=require("module$node_modules$$socket_DOT_io$component_emitter$index");const debug=global(require("module$node_modules$socket_DOT_io_client$node_modules$debug$src$browser")).default("socket.io-client:manager");
class Manager extends module.Emitter{constructor(uri,opts){var _a;super();this.nsps={};this.subs=[];uri&&"object"===typeof uri&&(opts=uri,uri=void 0);opts=opts||{};opts.path=opts.path||"/socket.io";this.opts=opts;engine_io_client_1.installTimerFunctions(this,opts);this.reconnection(!1!==opts.reconnection);this.reconnectionAttempts(opts.reconnectionAttempts||Infinity);this.reconnectionDelay(opts.reconnectionDelay||1E3);this.reconnectionDelayMax(opts.reconnectionDelayMax||5E3);this.randomizationFactor(null!==
(_a=opts.randomizationFactor)&&void 0!==_a?_a:.5);this.backoff=new backo2_js_1.Backoff({min:this.reconnectionDelay(),max:this.reconnectionDelayMax(),jitter:this.randomizationFactor()});this.timeout(null==opts.timeout?2E4:opts.timeout);this._readyState="closed";this.uri=uri;uri=opts.parser||parser;this.encoder=new uri.Encoder;this.decoder=new uri.Decoder;(this._autoConnect=!1!==opts.autoConnect)&&this.open()}reconnection(v){if(!arguments.length)return this._reconnection;this._reconnection=!!v;return this}reconnectionAttempts(v){if(void 0===
v)return this._reconnectionAttempts;this._reconnectionAttempts=v;return this}reconnectionDelay(v){var _a;if(void 0===v)return this._reconnectionDelay;this._reconnectionDelay=v;null===(_a=this.backoff)||void 0===_a?void 0:_a.setMin(v);return this}randomizationFactor(v){var _a;if(void 0===v)return this._randomizationFactor;this._randomizationFactor=v;null===(_a=this.backoff)||void 0===_a?void 0:_a.setJitter(v);return this}reconnectionDelayMax(v){var _a;if(void 0===v)return this._reconnectionDelayMax;
this._reconnectionDelayMax=v;null===(_a=this.backoff)||void 0===_a?void 0:_a.setMax(v);return this}timeout(v){if(!arguments.length)return this._timeout;this._timeout=v;return this}maybeReconnectOnOpen(){!this._reconnecting&&this._reconnection&&0===this.backoff.attempts&&this.reconnect()}open(fn){debug("readyState %s",this._readyState);if(~this._readyState.indexOf("open"))return this;debug("opening %s",this.uri);const socket=this.engine=new engine_io_client_1.Socket(this.uri,this.opts),self=this;this._readyState=
"opening";this.skipReconnect=!1;const openSubDestroy=on_js_1.on(socket,"open",function(){self.onopen();fn&&fn()}),errorSub=on_js_1.on(socket,"error",err=>{debug("error");self.cleanup();self._readyState="closed";this.emitReserved("error",err);fn?fn(err):self.maybeReconnectOnOpen()});if(!1!==this._timeout){const timeout=this._timeout;debug("connect attempt will timeout after %d",timeout);0===timeout&&openSubDestroy();const timer=this.setTimeoutFn(()=>{debug("connect attempt timed out after %d",timeout);
openSubDestroy();socket.close();socket.emit("error",Error("timeout"))},timeout);this.opts.autoUnref&&timer.unref();this.subs.push(function(){clearTimeout(timer)})}this.subs.push(openSubDestroy);this.subs.push(errorSub);return this}connect(fn){return this.open(fn)}onopen(){debug("open");this.cleanup();this._readyState="open";this.emitReserved("open");const socket=this.engine;this.subs.push(on_js_1.on(socket,"ping",this.onping.bind(this)),on_js_1.on(socket,"data",this.ondata.bind(this)),on_js_1.on(socket,
"error",this.onerror.bind(this)),on_js_1.on(socket,"close",this.onclose.bind(this)),on_js_1.on(this.decoder,"decoded",this.ondecoded.bind(this)))}onping(){this.emitReserved("ping")}ondata(data){try{this.decoder.add(data)}catch(e){this.onclose("parse error",e)}}ondecoded(packet){engine_io_client_1.nextTick(()=>{this.emitReserved("packet",packet)},this.setTimeoutFn)}onerror(err){debug("error",err);this.emitReserved("error",err)}socket(nsp,opts){let socket=this.nsps[nsp];socket||(socket=new socket_js_1.Socket(this,
nsp,opts),this.nsps[nsp]=socket);return socket}_destroy(socket){socket=Object.keys(this.nsps);for(const nsp of socket)if(this.nsps[nsp].active){debug("socket %s is still active, skipping close",nsp);return}this._close()}_packet(packet){debug("writing packet %j",packet);const encodedPackets=this.encoder.encode(packet);for(let i=0;i<encodedPackets.length;i++)this.engine.write(encodedPackets[i],packet.options)}cleanup(){debug("cleanup");this.subs.forEach(subDestroy=>subDestroy());this.subs.length=0;
this.decoder.destroy()}_close(){debug("disconnect");this.skipReconnect=!0;this._reconnecting=!1;this.onclose("forced close");this.engine&&this.engine.close()}disconnect(){return this._close()}onclose(reason,description){debug("closed due to %s",reason);this.cleanup();this.backoff.reset();this._readyState="closed";this.emitReserved("close",reason,description);this._reconnection&&!this.skipReconnect&&this.reconnect()}reconnect(){if(this._reconnecting||this.skipReconnect)return this;const self=this;
if(this.backoff.attempts>=this._reconnectionAttempts)debug("reconnect failed"),this.backoff.reset(),this.emitReserved("reconnect_failed"),this._reconnecting=!1;else{const delay=this.backoff.duration();debug("will wait %dms before reconnect attempt",delay);this._reconnecting=!0;const timer=this.setTimeoutFn(()=>{self.skipReconnect||(debug("attempting reconnect"),this.emitReserved("reconnect_attempt",self.backoff.attempts),self.skipReconnect||self.open(err=>{err?(debug("reconnect attempt error"),self._reconnecting=
!1,self.reconnect(),this.emitReserved("reconnect_error",err)):(debug("reconnect success"),self.onreconnect())}))},delay);this.opts.autoUnref&&timer.unref();this.subs.push(function(){clearTimeout(timer)})}}onreconnect(){const attempt=this.backoff.attempts;this._reconnecting=!1;this.backoff.reset();this.emitReserved("reconnect",attempt)}}exports.Manager=Manager}
//# sourceMappingURL=module$node_modules$socket_DOT_io_client$build$cjs$manager.js.map
