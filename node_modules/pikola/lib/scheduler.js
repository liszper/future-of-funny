'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.create = create;
exports.addLayer = addLayer;
exports.getExecutionDatesAfter = getExecutionDatesAfter;
exports.onFire = onFire;
exports.start = start;

var _resolution = require('./resolution');

var _resolution2 = _interopRequireDefault(_resolution);

var _recurrence = require('./recurrence');

var _recurrence2 = _interopRequireDefault(_recurrence);

var _index = require('./resolutions/index');

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var TIMER_RESOLUTION = 100;

/**
 * Gets default layer props
 */
function getDefaultLayerProps(resolution) {
  return {
    interval: 1,
    type: _recurrence2.default.Every,
    resolution: resolution
  };
}

/**
 * Creates an empty configuration object with default settings
 * @return {Object} Configuration object holding all the scheduling info
 */
function create() {
  var options = {
    layers: Object.keys(_resolution2.default).reduce(function (composed, res) {
      return _extends({}, composed, _defineProperty({}, _resolution2.default[res], getDefaultLayerProps(_resolution2.default[res])));
    }, {})
  };

  return options;
}

/**
 * Adds a recurrence layer to the config object
 * @param {Object} layer Object desribing one recurence layer
 * @param {Object} opt   Input configuration object that shall be modified
 * @return {Object} Configuration object holding new scheduling info
 */
function addLayer(layer, opt) {

  var options = _extends({}, opt, {
    layers: _extends({}, opt.layers, _defineProperty({}, layer.resolution, _extends({}, opt.layers[layer.resolution], layer)))
  });

  return options;
}

/**
 * Gets a number of dates which are based on defined options
 * @param  {Date}        the date from which the first exection shall start
 * @param  {Object} opt  schedule configuration
 * @param  {Number} num  maximum number of dates which should be returned
 * @return {Array}       array of dates describing future invocations
 */
function getExecutionDatesAfter(date, opt, num) {

  var i = 0;
  var dates = [];
  var start = date;

  while (dates.length < num && date) {
    date = getExecutionDateAfter(date, opt, !i);
    if (date != null && date >= start) {
      dates.push(date);
    }
    i++;
  }

  return dates;
}

/**
 * Registers fire callback
 *
 * @param  {Function} cb  Callback that should be fired after schedule is up
 * @param  {Object}   opt schedule configuration
 */
function onFire(cb, opt) {
  opt = _extends({}, opt, {
    callbacks: _extends({}, opt.callbacks, {
      fire: cb
    })
  });

  return opt;
}

/**
 * Plans next execution of provided trigger
 * @param  {Object} options   Trigger options
 * @param  {Date}   start     Start of the trigger
 * @param  {Date}   date      Date of previous execution
 */
function planNextExecution(options, start) {
  var date = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

  var nextRun = getExecutionDateAfter(date || start, options, date == null);
  var delay = nextRun - new Date();

  if (delay - options.executionDelay > 0) {
    doTimer(delay - options.executionDelay, TIMER_RESOLUTION, function () {
      options.executionDelay = (options.executionDelay + (new Date() - nextRun)) / 2;
      if (options.fire(nextRun) !== false) planNextExecution(options, start, nextRun);
    });
  } else {
    if (options.fire(nextRun) !== false) setTimeout(function () {
      return planNextExecution(options, start, nextRun);
    }, 0);
  }
}

/**
 * Sets up timer to fire in defined interval
 */
function doTimer(length, resolution, oncomplete) {
  var steps = length / 100 * (resolution / 10),
      speed = length / steps,
      start = new Date().getTime();

  var count = 0;

  function instance() {
    if (count++ >= steps) {
      oncomplete(steps, count);
    } else {
      var diff = new Date().getTime() - start - count * speed;
      setTimeout(instance, speed - diff);
    }
  }

  setTimeout(instance, speed);
}

/**
 * Starts timer execution
 * @param  {Date}   when      When this timer shall start
 * @param  {Object} options   Trigger options
 */
function start(when, options) {
  var delay = when - new Date();

  options.executionDelay = 0;

  if (delay > 0) {
    doTimer(delay, TIMER_RESOLUTION, function () {
      return planNextExecution(options, when);
    });
  } else {
    planNextExecution(options, when);
  }
}

/**
 * Gets the next possible execution based on the defined schedule and passed date
 *
 * @param  {Date}         the date from which the first exection shall start
 * @param  {Object} opt   schedule configuration
 * @return {Date}         Date of the next execution or null when next execution
 *                        is not possible
 */
function getExecutionDateAfter(date, opt, initialRun) {
  return (0, _index2.default)(opt)({
    date: date,
    initialRun: initialRun
  });
}